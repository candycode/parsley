<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Parsley: parsers.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Parsley
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">parsers.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="parsers_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef LEXERS_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define LEXERS_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00008"></a>00008 <span class="comment">//#include &lt;locale&gt; in case support for locale-dependent decimal format needed</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="_parser_8h.html">Parser.h</a>&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="_in_stream_8h.html">InStream.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="types_8h.html" title="Common types and wrappers.">types.h</a>&quot;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a><a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">00014</a> <span class="keyword">typedef</span> std::string <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>;
<a name="l00015"></a>00015 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00023"></a><a class="code" href="class_next_line_parser.html">00023</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_next_line_parser.html" title="Skips all blanks until next line.">NextLineParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00024"></a>00024 {
<a name="l00025"></a>00025 <span class="keyword">public</span>:
<a name="l00026"></a><a class="code" href="class_next_line_parser.html#a1b087e7048217db0252bbf542dd61a68">00026</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_next_line_parser.html#a1b087e7048217db0252bbf542dd61a68" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00027"></a><a class="code" href="class_next_line_parser.html#ad093ae20423a6d007ee7d1f2a9b6827c">00027</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_next_line_parser.html#ad093ae20423a6d007ee7d1f2a9b6827c" title="Value type in map.">ValueType</a>;
<a name="l00028"></a><a class="code" href="class_next_line_parser.html#a444ef3e5e9b3c765d65c955b866c17c2">00028</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_next_line_parser.html#a444ef3e5e9b3c765d65c955b866c17c2" title="Key type in map.">KeyType</a>;
<a name="l00029"></a><a class="code" href="class_next_line_parser.html#a324be971c1f4368ea390526fd6e91cfd">00029</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_next_line_parser.html#a324be971c1f4368ea390526fd6e91cfd">GetValues</a>()<span class="keyword"> const</span>
<a name="l00030"></a>00030 <span class="keyword">    </span>{ 
<a name="l00031"></a>00031         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00032"></a>00032         <span class="keywordflow">return</span> dummy;
<a name="l00033"></a>00033     }
<a name="l00034"></a><a class="code" href="class_next_line_parser.html#a2e5740fccbd46abca88f933307e4e50d">00034</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_next_line_parser.html#a2e5740fccbd46abca88f933307e4e50d">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const</span>
<a name="l00035"></a>00035 <span class="keyword">    </span>{
<a name="l00036"></a>00036         <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Not implemented&quot;</span> );
<a name="l00037"></a>00037     }
<a name="l00038"></a><a class="code" href="class_next_line_parser.html#aa7411d6bd4763c575c3005ae4c6d2fc2">00038</a>     <span class="keywordtype">bool</span> <a class="code" href="class_next_line_parser.html#aa7411d6bd4763c575c3005ae4c6d2fc2" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00039"></a>00039     {
<a name="l00040"></a>00040         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00041"></a>00041         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00042"></a>00042         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>(); 
<a name="l00043"></a>00043         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00044"></a>00044         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="class_next_line_parser.html#ad11b905268146975d7d3e9177f4aef43">IsBlank</a>( c ) ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00045"></a>00045         <span class="keywordflow">if</span>( c == <a class="code" href="class_next_line_parser.html#a6ea646ad801133179b15b806c08b7562">Eol</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00046"></a>00046         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00047"></a>00047         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00048"></a>00048     }
<a name="l00049"></a><a class="code" href="class_next_line_parser.html#aeb4692b7b528967a3ea32c85b8a9a4cf">00049</a>     <a class="code" href="class_next_line_parser.html" title="Skips all blanks until next line.">NextLineParser</a>* <a class="code" href="class_next_line_parser.html#aeb4692b7b528967a3ea32c85b8a9a4cf">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_next_line_parser.html" title="Skips all blanks until next line.">NextLineParser</a>( *<span class="keyword">this</span> ); }
<a name="l00050"></a>00050 <span class="keyword">private</span>:
<a name="l00051"></a><a class="code" href="class_next_line_parser.html#ad11b905268146975d7d3e9177f4aef43">00051</a>     <span class="keywordtype">bool</span> <a class="code" href="class_next_line_parser.html#ad11b905268146975d7d3e9177f4aef43">IsBlank</a>( <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c )<span class="keyword"> const</span>
<a name="l00052"></a>00052 <span class="keyword">    </span>{
<a name="l00053"></a>00053         <a class="code" href="types_8h.html#a1f9b22c3625387791aa9814dddd995dd">return ::IsSpace</a>( c ) != 0 &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00054"></a>00054     }
<a name="l00055"></a><a class="code" href="class_next_line_parser.html#a6ea646ad801133179b15b806c08b7562">00055</a>     <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> <a class="code" href="class_next_line_parser.html#a6ea646ad801133179b15b806c08b7562">Eol</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="charliteral">&#39;\n&#39;</span>; }
<a name="l00056"></a>00056 };
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00062"></a><a class="code" href="class_skip_blank_parser.html">00062</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_skip_blank_parser.html" title="Advance to the next non-blank character.">SkipBlankParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00063"></a>00063 {
<a name="l00064"></a>00064 <span class="keyword">public</span>:
<a name="l00065"></a><a class="code" href="class_skip_blank_parser.html#a286853a4410d7854b76aeb84208ac3ab">00065</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_skip_blank_parser.html#a286853a4410d7854b76aeb84208ac3ab" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00066"></a><a class="code" href="class_skip_blank_parser.html#ae00a2bb31c2aba2e341a0232991ee9fe">00066</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_skip_blank_parser.html#ae00a2bb31c2aba2e341a0232991ee9fe" title="Value type in map.">ValueType</a>;
<a name="l00067"></a><a class="code" href="class_skip_blank_parser.html#a2ba8da9a854e74dec7397294f57140ac">00067</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_skip_blank_parser.html#a2ba8da9a854e74dec7397294f57140ac" title="Key type in map.">KeyType</a>;
<a name="l00068"></a><a class="code" href="class_skip_blank_parser.html#a93eeb8d780d8713f07b9a088e24e5bf3">00068</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_skip_blank_parser.html#a93eeb8d780d8713f07b9a088e24e5bf3">GetValues</a>()<span class="keyword"> const</span>
<a name="l00069"></a>00069 <span class="keyword">    </span>{
<a name="l00070"></a>00070         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00071"></a>00071         <span class="keywordflow">return</span> dummy;
<a name="l00072"></a>00072     }
<a name="l00073"></a><a class="code" href="class_skip_blank_parser.html#af480feef3da1ee9a1d0e152cd99d53bd">00073</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_skip_blank_parser.html#af480feef3da1ee9a1d0e152cd99d53bd">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const</span>
<a name="l00074"></a>00074 <span class="keyword">    </span>{
<a name="l00075"></a>00075         <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Not implemented&quot;</span> );
<a name="l00076"></a>00076     }
<a name="l00077"></a><a class="code" href="class_skip_blank_parser.html#a68cf38262cf5d2ba0b78e4eca7ee2dc3">00077</a>     <span class="keywordtype">bool</span> <a class="code" href="class_skip_blank_parser.html#a68cf38262cf5d2ba0b78e4eca7ee2dc3" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00080"></a>00080         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00081"></a>00081         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00082"></a>00082         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="class_skip_blank_parser.html#a4321d501f770eb188ccc639e86a1a1eb">IsBlank</a>( c ) ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00083"></a>00083         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>(); 
<a name="l00084"></a>00084         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00085"></a>00085     }
<a name="l00086"></a><a class="code" href="class_skip_blank_parser.html#a4d71dda54b28fd42d3045846842e8599">00086</a>     <a class="code" href="class_skip_blank_parser.html" title="Advance to the next non-blank character.">SkipBlankParser</a>* <a class="code" href="class_skip_blank_parser.html#a4d71dda54b28fd42d3045846842e8599">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_skip_blank_parser.html" title="Advance to the next non-blank character.">SkipBlankParser</a>( *<span class="keyword">this</span> ); }
<a name="l00087"></a>00087 <span class="keyword">private</span>:
<a name="l00088"></a><a class="code" href="class_skip_blank_parser.html#a4321d501f770eb188ccc639e86a1a1eb">00088</a>     <span class="keywordtype">bool</span> <a class="code" href="class_skip_blank_parser.html#a4321d501f770eb188ccc639e86a1a1eb">IsBlank</a>( <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c )<span class="keyword"> const</span>
<a name="l00089"></a>00089 <span class="keyword">    </span>{
<a name="l00090"></a>00090         <a class="code" href="types_8h.html#a1f9b22c3625387791aa9814dddd995dd">return ::IsSpace</a>( c ) != 0;
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00097"></a><a class="code" href="class_skip_to_next_line_parser.html">00097</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_skip_to_next_line_parser.html" title="Advance to next line skipping all blank and non blank characters.">SkipToNextLineParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099 <span class="keyword">public</span>:
<a name="l00100"></a><a class="code" href="class_skip_to_next_line_parser.html#a136a9dc4418f6000babbedf5667fb13d">00100</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_skip_to_next_line_parser.html#a136a9dc4418f6000babbedf5667fb13d" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00101"></a><a class="code" href="class_skip_to_next_line_parser.html#af9d9c9686c4dfba391fceaade5e399a6">00101</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_skip_to_next_line_parser.html#af9d9c9686c4dfba391fceaade5e399a6" title="Value type in map.">ValueType</a>;
<a name="l00102"></a><a class="code" href="class_skip_to_next_line_parser.html#a51ff2329bdba13e42126d52f81725337">00102</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_skip_to_next_line_parser.html#a51ff2329bdba13e42126d52f81725337" title="Key type in map.">KeyType</a>;
<a name="l00103"></a><a class="code" href="class_skip_to_next_line_parser.html#a1b03c8b8b71e78ffc8090dae8db4ffe9">00103</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_skip_to_next_line_parser.html#a1b03c8b8b71e78ffc8090dae8db4ffe9">GetValues</a>()<span class="keyword"> const</span>
<a name="l00104"></a>00104 <span class="keyword">    </span>{
<a name="l00105"></a>00105         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00106"></a>00106         <span class="keywordflow">return</span> dummy;
<a name="l00107"></a>00107     }
<a name="l00108"></a><a class="code" href="class_skip_to_next_line_parser.html#ab8f4d954b29d41678f3101da101d4c70">00108</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_skip_to_next_line_parser.html#ab8f4d954b29d41678f3101da101d4c70">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const</span>
<a name="l00109"></a>00109 <span class="keyword">    </span>{
<a name="l00110"></a>00110         <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Not implemented&quot;</span> );
<a name="l00111"></a>00111     }
<a name="l00112"></a><a class="code" href="class_skip_to_next_line_parser.html#afa36fbb5f1aa872a9069c08f76ce0bd4">00112</a>     <span class="keywordtype">bool</span> <a class="code" href="class_skip_to_next_line_parser.html#afa36fbb5f1aa872a9069c08f76ce0bd4" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114         <span class="comment">//Always returns true: used to skip blanks</span>
<a name="l00115"></a>00115         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00116"></a>00116         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00117"></a>00117         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00118"></a>00118         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; c != <span class="charliteral">&#39;\n&#39;</span> ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00119"></a>00119         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>(); 
<a name="l00120"></a>00120         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00121"></a>00121     }
<a name="l00122"></a><a class="code" href="class_skip_to_next_line_parser.html#a26062044c94ee2ed057470b6d9062bd9">00122</a>     <a class="code" href="class_skip_to_next_line_parser.html" title="Advance to next line skipping all blank and non blank characters.">SkipToNextLineParser</a>* <a class="code" href="class_skip_to_next_line_parser.html#a26062044c94ee2ed057470b6d9062bd9">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_skip_to_next_line_parser.html" title="Advance to next line skipping all blank and non blank characters.">SkipToNextLineParser</a>( *<span class="keyword">this</span> ); }
<a name="l00123"></a>00123 };
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00128"></a><a class="code" href="class_blank_parser.html">00128</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130 <span class="keyword">public</span>:
<a name="l00131"></a><a class="code" href="class_blank_parser.html#a120fe0d1adce9fb7d5d1f4f6f30e64eb">00131</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_blank_parser.html#a120fe0d1adce9fb7d5d1f4f6f30e64eb" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00132"></a><a class="code" href="class_blank_parser.html#a001a29122ea3e0ec45051ab462e9338d">00132</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_blank_parser.html#a001a29122ea3e0ec45051ab462e9338d" title="Value type in map.">ValueType</a>;
<a name="l00133"></a><a class="code" href="class_blank_parser.html#a76a4d03bcb9c25e3d91d48e628e2c696">00133</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_blank_parser.html#a76a4d03bcb9c25e3d91d48e628e2c696" title="Key type in map.">KeyType</a>;
<a name="l00134"></a><a class="code" href="class_blank_parser.html#a380648f337db2554a13dee10e183cf39">00134</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_blank_parser.html#a380648f337db2554a13dee10e183cf39">GetValues</a>()<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">    </span>{
<a name="l00136"></a>00136         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00137"></a>00137         <span class="keywordflow">return</span> dummy;
<a name="l00138"></a>00138     }
<a name="l00139"></a><a class="code" href="class_blank_parser.html#aeb379e07da9a833672fc8b1931f45765">00139</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_blank_parser.html#aeb379e07da9a833672fc8b1931f45765">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const</span>
<a name="l00140"></a>00140 <span class="keyword">    </span>{
<a name="l00141"></a>00141         <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Not implemented&quot;</span> );
<a name="l00142"></a>00142     }
<a name="l00145"></a><a class="code" href="class_blank_parser.html#a712ed29e67ffdff662c768ab75b7d22d">00145</a>     <span class="keywordtype">bool</span> <a class="code" href="class_blank_parser.html#a712ed29e67ffdff662c768ab75b7d22d">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00148"></a>00148         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00149"></a>00149         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00150"></a>00150         <span class="keywordflow">if</span>( !<a class="code" href="class_blank_parser.html#a59ef7797f0d6919e33e5d4fa8d6d5144">IsBlank</a>( c ) ) { is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>(); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00151"></a>00151         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="class_blank_parser.html#a59ef7797f0d6919e33e5d4fa8d6d5144">IsBlank</a>( c ) ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00152"></a>00152         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>(); 
<a name="l00153"></a>00153         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00154"></a>00154     }
<a name="l00155"></a><a class="code" href="class_blank_parser.html#a6118c2556ab2afe8b0fe7f226a62af28">00155</a>     <a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a>* <a class="code" href="class_blank_parser.html#a6118c2556ab2afe8b0fe7f226a62af28">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a>( *<span class="keyword">this</span> ); }
<a name="l00156"></a>00156 <span class="keyword">private</span>:
<a name="l00157"></a><a class="code" href="class_blank_parser.html#a59ef7797f0d6919e33e5d4fa8d6d5144">00157</a>     <span class="keywordtype">bool</span> <a class="code" href="class_blank_parser.html#a59ef7797f0d6919e33e5d4fa8d6d5144">IsBlank</a>( <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c )<span class="keyword"> const</span>
<a name="l00158"></a>00158 <span class="keyword">    </span>{
<a name="l00159"></a>00159         <a class="code" href="types_8h.html#a1f9b22c3625387791aa9814dddd995dd">return ::IsSpace</a>( c ) != 0;
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161 };
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00166"></a><a class="code" href="class_eof_parser.html">00166</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_eof_parser.html" title="Parse end of file character.">EofParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168 <span class="keyword">public</span>:
<a name="l00169"></a><a class="code" href="class_eof_parser.html#a025c69be9d0d4bb7f5219ed3c43c105c">00169</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_eof_parser.html#a025c69be9d0d4bb7f5219ed3c43c105c" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00170"></a><a class="code" href="class_eof_parser.html#a5708c69efbb10ed2ec2cc7037cb55c02">00170</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_eof_parser.html#a5708c69efbb10ed2ec2cc7037cb55c02" title="Value type in map.">ValueType</a>;
<a name="l00171"></a><a class="code" href="class_eof_parser.html#ac1c1789c86ed63bc75df7ea962bd6b97">00171</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_eof_parser.html#ac1c1789c86ed63bc75df7ea962bd6b97" title="Key type in map.">KeyType</a>;
<a name="l00172"></a><a class="code" href="class_eof_parser.html#ad3abe48d992a0da35a0629494ae632e3">00172</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_eof_parser.html#ad3abe48d992a0da35a0629494ae632e3">GetValues</a>()<span class="keyword"> const</span>
<a name="l00173"></a>00173 <span class="keyword">    </span>{
<a name="l00174"></a>00174         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00175"></a>00175         <span class="keywordflow">return</span> dummy;
<a name="l00176"></a>00176     }
<a name="l00177"></a><a class="code" href="class_eof_parser.html#a40b940c096f575929d71df1041a295e7">00177</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_eof_parser.html#a40b940c096f575929d71df1041a295e7">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const</span>
<a name="l00178"></a>00178 <span class="keyword">    </span>{
<a name="l00179"></a>00179         <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Not implemented&quot;</span> );
<a name="l00180"></a>00180     }
<a name="l00182"></a><a class="code" href="class_eof_parser.html#a6a956aef73b99feec45564a07119dcbf">00182</a>     <span class="keywordtype">bool</span> <a class="code" href="class_eof_parser.html#a6a956aef73b99feec45564a07119dcbf">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00183"></a>00183     {
<a name="l00184"></a>00184         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a4b975369f83da5e11d82cf9c74577be3">eof</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00185"></a>00185         <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00186"></a>00186     }
<a name="l00187"></a><a class="code" href="class_eof_parser.html#afb8f0c590901cb9fdc65226900cb0b48">00187</a>     <a class="code" href="class_eof_parser.html" title="Parse end of file character.">EofParser</a>* <a class="code" href="class_eof_parser.html#afb8f0c590901cb9fdc65226900cb0b48">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_eof_parser.html" title="Parse end of file character.">EofParser</a>( *<span class="keyword">this</span> ); }
<a name="l00188"></a>00188 };
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00194"></a><a class="code" href="class_u_int_parser.html">00194</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_u_int_parser.html" title="Parse unsigned int.">UIntParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196 <span class="keyword">public</span>:
<a name="l00197"></a><a class="code" href="class_u_int_parser.html#af18c03e3dc5cb8001eb4a99e4c08da89">00197</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_u_int_parser.html#af18c03e3dc5cb8001eb4a99e4c08da89" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00198"></a><a class="code" href="class_u_int_parser.html#aeda66b2f3a8bb21ac3943f1309a7e259">00198</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_u_int_parser.html#aeda66b2f3a8bb21ac3943f1309a7e259" title="Value type in map.">ValueType</a>;
<a name="l00199"></a><a class="code" href="class_u_int_parser.html#aea828ed108ba365f66f9ccdbe5cdffbc">00199</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_u_int_parser.html#aea828ed108ba365f66f9ccdbe5cdffbc" title="Key type in map.">KeyType</a>;
<a name="l00200"></a><a class="code" href="class_u_int_parser.html#a660f9eddee5cc229d988270fe8b4339c">00200</a>     <span class="keyword">typedef</span> <a class="code" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a> <a class="code" href="class_u_int_parser.html#a660f9eddee5cc229d988270fe8b4339c">Char</a>;
<a name="l00201"></a><a class="code" href="class_u_int_parser.html#a6a171a8cffc6909cd066ab635baef576">00201</a>     <a class="code" href="class_u_int_parser.html#a6a171a8cffc6909cd066ab635baef576">UIntParser</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; name = <a class="code" href="class_u_int_parser.html#aea828ed108ba365f66f9ccdbe5cdffbc" title="Key type in map.">KeyType</a>() ) : <a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba" title="Name of parsed value in value map.">name_</a>( name ) {}
<a name="l00202"></a><a class="code" href="class_u_int_parser.html#ae0bceaffec9b2d00f073a15fedebd2ca">00202</a>     <a class="code" href="class_u_int_parser.html#ae0bceaffec9b2d00f073a15fedebd2ca">UIntParser</a>( <span class="keyword">const</span> <a class="code" href="class_u_int_parser.html" title="Parse unsigned int.">UIntParser</a>&amp; p ) : <a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba" title="Name of parsed value in value map.">name_</a>( p.<a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba" title="Name of parsed value in value map.">name_</a> ), <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>( p.<a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a> ), <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>( p.<a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a> ) {}
<a name="l00206"></a><a class="code" href="class_u_int_parser.html#a21a05fdbbb4b1f487698fcad4467d751">00206</a>     <span class="keywordtype">bool</span> <a class="code" href="class_u_int_parser.html#a21a05fdbbb4b1f487698fcad4467d751">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208         <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>.clear();
<a name="l00209"></a>00209         <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>.clear();
<a name="l00210"></a>00210         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00211"></a>00211         <a class="code" href="class_u_int_parser.html#a660f9eddee5cc229d988270fe8b4339c">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00212"></a>00212         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00213"></a>00213         <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">IsDigit</a>( c ) == 0 )
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00216"></a>00216             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>.push_back( c );
<a name="l00219"></a>00219         <a class="code" href="class_u_int_parser.html#a109116fee0a314391cf6b25da57fb8a2">GetNumber</a>( is );
<a name="l00220"></a>00220         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     
<a name="l00226"></a><a class="code" href="class_u_int_parser.html#aede00d8f491cfe1e667265cb1ebe8dd9">00226</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_u_int_parser.html#aede00d8f491cfe1e667265cb1ebe8dd9">GetValues</a>()<span class="keyword"> const</span>
<a name="l00227"></a>00227 <span class="keyword">    </span>{
<a name="l00228"></a>00228         <span class="keywordflow">if</span>( <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>.empty() &amp;&amp; !<a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>.empty() )
<a name="l00229"></a>00229         {
<a name="l00230"></a>00230             <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba" title="Name of parsed value in value map.">name_</a>, <span class="keywordtype">unsigned</span>( ::<a class="code" href="types_8h.html#a112a58891f3a9d42a3ce98e021c2873f">ToInt</a>( <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>.c_str() ) ) ) );
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232         <span class="keywordflow">return</span> <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>;
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234 
<a name="l00237"></a><a class="code" href="class_u_int_parser.html#ac1dcf7a9b21bee8e10b3e37b0441b84d">00237</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_u_int_parser.html#ac1dcf7a9b21bee8e10b3e37b0441b84d">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00238"></a>00238 <span class="keyword">    </span>{
<a name="l00239"></a>00239         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_u_int_parser.html#aede00d8f491cfe1e667265cb1ebe8dd9">GetValues</a>();
<a name="l00240"></a>00240         Values::const_iterator i = v.find( k );
<a name="l00241"></a>00241         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00242"></a>00242         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00246"></a><a class="code" href="class_u_int_parser.html#a0b138c4f8b68918ce71d42f031f12b74">00246</a>     <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; <a class="code" href="class_u_int_parser.html#a0b138c4f8b68918ce71d42f031f12b74">GetText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>; }
<a name="l00247"></a>00247 
<a name="l00248"></a><a class="code" href="class_u_int_parser.html#a4764e58f4f44f78255721bc48bf738cb">00248</a>     <a class="code" href="class_u_int_parser.html" title="Parse unsigned int.">UIntParser</a>* <a class="code" href="class_u_int_parser.html#a4764e58f4f44f78255721bc48bf738cb">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_u_int_parser.html#a6a171a8cffc6909cd066ab635baef576">UIntParser</a>( *<span class="keyword">this</span> ); }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">private</span>:
<a name="l00251"></a><a class="code" href="class_u_int_parser.html#a109116fee0a314391cf6b25da57fb8a2">00251</a>     <span class="keywordtype">void</span> <a class="code" href="class_u_int_parser.html#a109116fee0a314391cf6b25da57fb8a2">GetNumber</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span>;
<a name="l00254"></a>00254         <a class="code" href="class_u_int_parser.html#a660f9eddee5cc229d988270fe8b4339c">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00255"></a>00255         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span>;
<a name="l00256"></a>00256         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">::IsDigit</a>( c ) != 0 )
<a name="l00257"></a>00257         {
<a name="l00258"></a>00258             <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>.push_back( c );
<a name="l00259"></a>00259             c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263 
<a name="l00265"></a><a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba">00265</a>     <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a> <a class="code" href="class_u_int_parser.html#afc31d85fdd1294933edb5e67224b02ba" title="Name of parsed value in value map.">name_</a>;
<a name="l00267"></a><a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0">00267</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_u_int_parser.html#a348ab24ca24e8be1c7a90e2c78fe14e0" title="Parsed text.">token_</a>;
<a name="l00271"></a><a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">00271</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_u_int_parser.html#a47c008e0c1c3d18bfcbaa902b4d89516">valueMap_</a>;
<a name="l00272"></a>00272 };
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00280"></a><a class="code" href="class_int_parser.html">00280</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_int_parser.html" title="Parse signed integer values.">IntParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282 <span class="keyword">public</span>:
<a name="l00283"></a><a class="code" href="class_int_parser.html#a732b46b68bbf651bbbe621511f82baef">00283</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_int_parser.html#a732b46b68bbf651bbbe621511f82baef" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00284"></a><a class="code" href="class_int_parser.html#a7ef1e0157a246cb7c1b8c58bd1a65520">00284</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_int_parser.html#a7ef1e0157a246cb7c1b8c58bd1a65520" title="Value type in map.">ValueType</a>;
<a name="l00285"></a><a class="code" href="class_int_parser.html#a411d3b907f4346c1cc1bb256d50fca2d">00285</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_int_parser.html#a411d3b907f4346c1cc1bb256d50fca2d" title="Key type in map.">KeyType</a>;
<a name="l00286"></a><a class="code" href="class_int_parser.html#abcb6f2de187f48ecee3a46300a4285e6">00286</a>     <span class="keyword">typedef</span> <a class="code" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a> <a class="code" href="class_int_parser.html#abcb6f2de187f48ecee3a46300a4285e6">Char</a>;
<a name="l00287"></a><a class="code" href="class_int_parser.html#ad8ee8b4f44e5e13619f90d5f2922ff90">00287</a>     <a class="code" href="class_int_parser.html#ad8ee8b4f44e5e13619f90d5f2922ff90">IntParser</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; name = <a class="code" href="class_int_parser.html#a411d3b907f4346c1cc1bb256d50fca2d" title="Key type in map.">KeyType</a>() ) : <a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b" title="Name of parsed value in value map.">name_</a>( name ) {}
<a name="l00288"></a><a class="code" href="class_int_parser.html#ab9a764987a6cfe2d98b760503436f05b">00288</a>     <a class="code" href="class_int_parser.html#ab9a764987a6cfe2d98b760503436f05b">IntParser</a>( <span class="keyword">const</span> <a class="code" href="class_int_parser.html" title="Parse signed integer values.">IntParser</a>&amp; p ) : <a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b" title="Name of parsed value in value map.">name_</a>( p.<a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b" title="Name of parsed value in value map.">name_</a> ), <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a>( p.<a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a> ), <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>( p.<a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a> ) {}
<a name="l00292"></a><a class="code" href="class_int_parser.html#a87a522743f712f600dcbd3f6e0b42d93">00292</a>     <span class="keywordtype">bool</span> <a class="code" href="class_int_parser.html#a87a522743f712f600dcbd3f6e0b42d93">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00293"></a>00293     {
<a name="l00294"></a>00294         <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a>.clear();
<a name="l00295"></a>00295         <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>.clear();
<a name="l00296"></a>00296         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00297"></a>00297         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00298"></a>00298         {
<a name="l00299"></a>00299         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00300"></a>00300         <a class="code" href="class_int_parser.html#abcb6f2de187f48ecee3a46300a4285e6">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00301"></a>00301         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00302"></a>00302         <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;+&#39;</span> || c == <span class="charliteral">&#39;-&#39;</span> )
<a name="l00303"></a>00303         {
<a name="l00304"></a>00304             <a class="code" href="class_u_int_parser.html" title="Parse unsigned int.">UIntParser</a> uil;
<a name="l00305"></a>00305             <span class="keywordflow">if</span>( uil.<a class="code" href="class_u_int_parser.html#a21a05fdbbb4b1f487698fcad4467d751">Parse</a>( is ) ) { <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a> = c + uil.<a class="code" href="class_u_int_parser.html#a0b138c4f8b68918ce71d42f031f12b74">GetText</a>(); ok = <span class="keyword">true</span>; }
<a name="l00306"></a>00306             <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;          
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308         <span class="keywordflow">else</span>
<a name="l00309"></a>00309         {
<a name="l00310"></a>00310             <a class="code" href="class_u_int_parser.html" title="Parse unsigned int.">UIntParser</a> uil;
<a name="l00311"></a>00311             <span class="keywordflow">if</span>( uil.<a class="code" href="class_u_int_parser.html#a21a05fdbbb4b1f487698fcad4467d751">Parse</a>( is ) ) { <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a> = uil.<a class="code" href="class_u_int_parser.html#a0b138c4f8b68918ce71d42f031f12b74">GetText</a>(); ok = <span class="keyword">true</span>; }
<a name="l00312"></a>00312             <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00313"></a>00313         }
<a name="l00314"></a>00314         ok = <span class="keyword">true</span>;
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316         <span class="keywordflow">return</span> ok;
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     
<a name="l00322"></a><a class="code" href="class_int_parser.html#aa20466a70d1bb762884c786f1893007f">00322</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_int_parser.html#aa20466a70d1bb762884c786f1893007f">GetValues</a>()<span class="keyword"> const</span>
<a name="l00323"></a>00323 <span class="keyword">    </span>{
<a name="l00324"></a>00324         <span class="comment">//valueMap_[]= won&#39;t work on Apple gcc 4.0.x</span>
<a name="l00325"></a>00325         <span class="keywordflow">if</span>( <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>.empty() &amp;&amp; !<a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a>.empty() )
<a name="l00326"></a>00326         {
<a name="l00327"></a>00327             <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b" title="Name of parsed value in value map.">name_</a>, <span class="keywordtype">int</span>( ::<a class="code" href="types_8h.html#a112a58891f3a9d42a3ce98e021c2873f">ToInt</a>( <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a>.c_str() ) ) ) );
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         <span class="keywordflow">return</span> <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00334"></a><a class="code" href="class_int_parser.html#ac8988385bb2b0e58b9707da55a6ae6b0">00334</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_int_parser.html#ac8988385bb2b0e58b9707da55a6ae6b0">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00335"></a>00335 <span class="keyword">    </span>{
<a name="l00336"></a>00336         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_int_parser.html#aa20466a70d1bb762884c786f1893007f">GetValues</a>();
<a name="l00337"></a>00337         Values::const_iterator i = v.find( k );
<a name="l00338"></a>00338         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00339"></a>00339         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341 
<a name="l00342"></a><a class="code" href="class_int_parser.html#a3e42aacf3e39f6de05e7316c10ca69b5">00342</a>     <a class="code" href="class_int_parser.html" title="Parse signed integer values.">IntParser</a>* <a class="code" href="class_int_parser.html#a3e42aacf3e39f6de05e7316c10ca69b5">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_int_parser.html#ad8ee8b4f44e5e13619f90d5f2922ff90">IntParser</a>( *<span class="keyword">this</span> ); } 
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">private</span>:
<a name="l00346"></a><a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b">00346</a>     <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a> <a class="code" href="class_int_parser.html#ab5199c15a1a75f2aaf12e68d8ef6971b" title="Name of parsed value in value map.">name_</a>;
<a name="l00348"></a><a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c">00348</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_int_parser.html#aa44494fdbdf3804f7280ff1d81d8f65c" title="Parsed text.">token_</a>;
<a name="l00352"></a><a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">00352</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_int_parser.html#ab567fa2d873b638bf4539948fd1a068d">valueMap_</a>;
<a name="l00353"></a>00353 };
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00366"></a><a class="code" href="class_float_parser.html">00366</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_float_parser.html" title="Float parser.">FloatParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00367"></a>00367 {
<a name="l00368"></a>00368 <span class="keyword">public</span>:
<a name="l00369"></a><a class="code" href="class_float_parser.html#aa963f11f2d77f1142249e4c0f928caa1">00369</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_float_parser.html#aa963f11f2d77f1142249e4c0f928caa1" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00370"></a><a class="code" href="class_float_parser.html#a5e7d5b78faa833efd71e66018f344a2e">00370</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_float_parser.html#a5e7d5b78faa833efd71e66018f344a2e" title="Value type in map.">ValueType</a>;
<a name="l00371"></a><a class="code" href="class_float_parser.html#a72dca9c95127605bdabaa9ce56e182e9">00371</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_float_parser.html#a72dca9c95127605bdabaa9ce56e182e9" title="Key type in map.">KeyType</a>;
<a name="l00372"></a><a class="code" href="class_float_parser.html#a7d912b4843818cdaf0088f2d6737bc4c">00372</a>     <a class="code" href="class_float_parser.html#a7d912b4843818cdaf0088f2d6737bc4c">FloatParser</a>( <span class="keyword">const</span> <a class="code" href="class_float_parser.html" title="Float parser.">FloatParser</a>&amp; p ) : <a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be" title="Name of parsed value in value map.">name_</a>( p.<a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be" title="Name of parsed value in value map.">name_</a> ), <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>( p.<a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a> ) {}
<a name="l00373"></a><a class="code" href="class_float_parser.html#a085dd64b877dd875214ab608e76c7d1a">00373</a>     <a class="code" href="class_float_parser.html#a085dd64b877dd875214ab608e76c7d1a">FloatParser</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; name = <a class="code" href="class_float_parser.html#a72dca9c95127605bdabaa9ce56e182e9" title="Key type in map.">KeyType</a>() ) : <a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be" title="Name of parsed value in value map.">name_</a>( name ) {} 
<a name="l00374"></a><a class="code" href="class_float_parser.html#ad65caf3f6cfcae6029880cb0c578d1fe">00374</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; <a class="code" href="class_float_parser.html#ad65caf3f6cfcae6029880cb0c578d1fe">GetText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a> ; }
<a name="l00377"></a><a class="code" href="class_float_parser.html#a16839ebec28e75e92b1bb6ae6094a63d">00377</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="class_float_parser.html#a16839ebec28e75e92b1bb6ae6094a63d">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )  
<a name="l00378"></a>00378     {
<a name="l00379"></a>00379         <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.clear();
<a name="l00380"></a>00380         <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>.clear();
<a name="l00381"></a>00381         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00382"></a>00382         <span class="comment">// in case support for locale-dependent decimal separator is needed:</span>
<a name="l00383"></a>00383         <span class="comment">//Char decimalSeparator_ = </span>
<a name="l00384"></a>00384         <span class="comment">//    std::use_facet&lt; std::numpunct&lt; Char &gt; &gt;( is.getloc() ).decimal_point ();</span>
<a name="l00385"></a>00385         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00386"></a>00386         {
<a name="l00387"></a>00387         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00388"></a>00388         <span class="keyword">const</span> <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00389"></a>00389         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;  
<a name="l00390"></a>00390         <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;+&#39;</span> || c == <span class="charliteral">&#39;-&#39;</span> )
<a name="l00391"></a>00391         {
<a name="l00392"></a>00392             <span class="keywordflow">if</span>( <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#aba59b5e4fabb0b50af7938d965976b60">FloatParser::MatchUnsigned</a>, is, c ) ) <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a> = c + <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;.&#39;</span> )
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396             <span class="keywordflow">if</span>( <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a5c5d55030712175c8d9d6234feffe051">FloatParser::MatchFractional</a>, is, c ) ) <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a> = c + <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>;
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">IsDigit</a>( c ) != 0 )
<a name="l00399"></a>00399         { 
<a name="l00400"></a>00400             is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00401"></a>00401             <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#aba59b5e4fabb0b50af7938d965976b60">FloatParser::MatchUnsigned</a>, is, 0 );
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403         <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00404"></a>00404         ok = <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.length() &gt; 0;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406         <span class="keywordflow">return</span> ok;
<a name="l00407"></a>00407     }
<a name="l00411"></a><a class="code" href="class_float_parser.html#aad67cd4267c141182671b8127531c6f8">00411</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_float_parser.html#aad67cd4267c141182671b8127531c6f8">GetValues</a>()<span class="keyword"> const</span>
<a name="l00412"></a>00412 <span class="keyword">    </span>{
<a name="l00413"></a>00413         <span class="keywordflow">if</span>( <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>.empty() &amp;&amp; !<a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.empty() )
<a name="l00414"></a>00414         {
<a name="l00415"></a>00415             <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be" title="Name of parsed value in value map.">name_</a>, ::<a class="code" href="types_8h.html#a4304c0e8cee239cf7b22c2f23906335a">ToFloat</a>( <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.c_str() ) ) );
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417         <span class="keywordflow">return</span> <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>;
<a name="l00418"></a>00418     }
<a name="l00421"></a><a class="code" href="class_float_parser.html#a5fb41fbf9d3d4331b0a19b5af0b1544e">00421</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_float_parser.html#a5fb41fbf9d3d4331b0a19b5af0b1544e">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00422"></a>00422 <span class="keyword">    </span>{
<a name="l00423"></a>00423         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_float_parser.html#aad67cd4267c141182671b8127531c6f8">GetValues</a>();
<a name="l00424"></a>00424         Values::const_iterator i = v.find( k );
<a name="l00425"></a>00425         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00426"></a>00426         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428 
<a name="l00429"></a><a class="code" href="class_float_parser.html#ad54ee48163136284323697527651fbff">00429</a>     <span class="keyword">virtual</span> <a class="code" href="class_float_parser.html" title="Float parser.">FloatParser</a>* <a class="code" href="class_float_parser.html#ad54ee48163136284323697527651fbff">Clone</a>()<span class="keyword"> const</span>
<a name="l00430"></a>00430 <span class="keyword">    </span>{
<a name="l00431"></a>00431         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_float_parser.html#a7d912b4843818cdaf0088f2d6737bc4c">FloatParser</a>( *<span class="keyword">this</span> );
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="keyword">private</span>:
<a name="l00436"></a><a class="code" href="class_float_parser.html#a177749fb13998e504a0aad6828e5a447">00436</a>     <span class="keyword">typedef</span> bool( <a class="code" href="class_float_parser.html" title="Float parser.">FloatParser</a>::*<a class="code" href="class_float_parser.html#a177749fb13998e504a0aad6828e5a447">MatchMethod</a> )( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; ); 
<a name="l00437"></a>00437 
<a name="l00438"></a><a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">00438</a>     <span class="keywordtype">bool</span> <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( <a class="code" href="class_float_parser.html#a177749fb13998e504a0aad6828e5a447">MatchMethod</a> f, <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is, <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> last )
<a name="l00439"></a>00439     {
<a name="l00440"></a>00440         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00441"></a>00441         <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> tmp = <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>; <span class="comment">// save current value</span>
<a name="l00442"></a>00442         <span class="keyword">const</span> <a class="code" href="types_8h.html#ac88fd1b755dd7fbb41068b7d30994e7e">StreamPos</a> pos = is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>();
<a name="l00443"></a>00443         <span class="keyword">const</span> <span class="keywordtype">bool</span> m = (this-&gt;*f)( is );
<a name="l00444"></a>00444         <span class="keywordflow">if</span>( !m )
<a name="l00445"></a>00445         {
<a name="l00446"></a>00446             <span class="comment">//restore previous value</span>
<a name="l00447"></a>00447             <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a> = tmp;
<a name="l00448"></a>00448             <span class="comment">//restore stream pointer</span>
<a name="l00449"></a>00449             is.<a class="code" href="class_in_ch_stream.html#acb6a4bb4f9d6c4d702b0eb9d0d86f9c3">seekg</a>( pos );
<a name="l00450"></a>00450         }
<a name="l00451"></a>00451         <span class="comment">//last == 0 is a signal that enough input has been validated to make</span>
<a name="l00452"></a>00452         <span class="comment">//the token a valid float </span>
<a name="l00453"></a>00453         <span class="keywordflow">return</span> last == 0 || m;
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="class_float_parser.html#aba59b5e4fabb0b50af7938d965976b60">00456</a>     <span class="keywordtype">bool</span> <a class="code" href="class_float_parser.html#aba59b5e4fabb0b50af7938d965976b60">MatchUnsigned</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00459"></a>00459         <span class="keyword">const</span> <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00460"></a>00460         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00461"></a>00461         <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">IsDigit</a>( c ) != 0 )
<a name="l00462"></a>00462         { <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( c ); <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#aba59b5e4fabb0b50af7938d965976b60">FloatParser::MatchUnsigned</a>, is, 0 ); <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00463"></a>00463         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;.&#39;</span> )
<a name="l00464"></a>00464         { <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( c ); <span class="keywordflow">return</span> <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a5c5d55030712175c8d9d6234feffe051">FloatParser::MatchFractional</a>, is, c ); }
<a name="l00465"></a>00465         is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00466"></a>00466         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468 
<a name="l00469"></a><a class="code" href="class_float_parser.html#a5c5d55030712175c8d9d6234feffe051">00469</a>     <span class="keywordtype">bool</span> <a class="code" href="class_float_parser.html#a5c5d55030712175c8d9d6234feffe051">MatchFractional</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00472"></a>00472         <span class="keyword">const</span> <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00473"></a>00473         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00474"></a>00474         <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">IsDigit</a>( c ) )
<a name="l00475"></a>00475         {
<a name="l00476"></a>00476             <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( c ); <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a5c5d55030712175c8d9d6234feffe051">FloatParser::MatchFractional</a>, is, 0 );
<a name="l00477"></a>00477             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00478"></a>00478         }
<a name="l00479"></a>00479         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;E&#39;</span> || c == <span class="charliteral">&#39;D&#39;</span> || 
<a name="l00480"></a>00480                  c == <span class="charliteral">&#39;e&#39;</span> || c == <span class="charliteral">&#39;d&#39;</span> )
<a name="l00481"></a>00481         {
<a name="l00482"></a>00482              <span class="comment">// problem: on windows &#39;D&#39; (with both vc++ and migw) is properly</span>
<a name="l00483"></a>00483              <span class="comment">// understood but not on linux/mac: need to force a &#39;D&#39; -&gt; &#39;E&#39; translation</span>
<a name="l00484"></a>00484              <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( <span class="charliteral">&#39;E&#39;</span> ); <span class="keywordflow">return</span> <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a66ba8027b72a4b96d765b92791532160">FloatParser::MatchExponent</a>, is, c );
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486         is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00487"></a>00487         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00488"></a>00488     }
<a name="l00489"></a><a class="code" href="class_float_parser.html#a66ba8027b72a4b96d765b92791532160">00489</a>     <span class="keywordtype">bool</span> <a class="code" href="class_float_parser.html#a66ba8027b72a4b96d765b92791532160">MatchExponent</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) 
<a name="l00490"></a>00490     {
<a name="l00491"></a>00491         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00492"></a>00492         <span class="keyword">const</span> <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00493"></a>00493         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00494"></a>00494         <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;+&#39;</span> || c == <span class="charliteral">&#39;-&#39;</span> )
<a name="l00495"></a>00495         {
<a name="l00496"></a>00496             <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( c ); <span class="keywordflow">return</span> <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a66ba8027b72a4b96d765b92791532160">FloatParser::MatchExponent</a>, is, c );
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">IsDigit</a>( c ) )
<a name="l00499"></a>00499         {
<a name="l00500"></a>00500             <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>.push_back( c ); <a class="code" href="class_float_parser.html#ab4e51c9fe54d7263216b01954d9d3a02">Apply</a>( &amp;<a class="code" href="class_float_parser.html#a66ba8027b72a4b96d765b92791532160">FloatParser::MatchExponent</a>, is,  0 ); <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00501"></a>00501         }
<a name="l00502"></a>00502         is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00503"></a>00503         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00504"></a>00504     }
<a name="l00506"></a><a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be">00506</a>     <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a> <a class="code" href="class_float_parser.html#a967d19f23a4ca4140431f6d514fd89be" title="Name of parsed value in value map.">name_</a>;
<a name="l00508"></a><a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581">00508</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_float_parser.html#aed1480b69aa428e96c3d963342c03581" title="Parsed text.">token_</a>;
<a name="l00513"></a><a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53">00513</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_float_parser.html#ae4b937feab275a09cdeba04393affb53" title="Name -&gt; Value map. Declared mutable to allow for lazy behavior: number is converted and stored into m...">valueMap_</a>;
<a name="l00514"></a>00514 };
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00519"></a><a class="code" href="struct_alpha_num_validator.html">00519</a> <span class="comment"></span><span class="keyword">struct </span><a class="code" href="struct_alpha_num_validator.html" title="Validator for alphanumeric strings.">AlphaNumValidator</a>
<a name="l00520"></a>00520 {
<a name="l00522"></a><a class="code" href="struct_alpha_num_validator.html#ab3940a8c114d6864ebca56e3ddf14a92">00522</a>     <span class="keywordtype">bool</span> <a class="code" href="struct_alpha_num_validator.html#ab3940a8c114d6864ebca56e3ddf14a92" title="Validates any alphanumeric value.">Validate</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp;, <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> newChar )<span class="keyword"> const</span>
<a name="l00523"></a>00523 <span class="keyword">    </span>{
<a name="l00524"></a>00524         <a class="code" href="types_8h.html#a7f9469381012a59f7578cd346fe3f66b">return ::IsAlnum</a>( newChar ) != 0;
<a name="l00525"></a>00525     }
<a name="l00526"></a>00526     
<a name="l00527"></a><a class="code" href="struct_alpha_num_validator.html#a3f4f3ccd9c334a41b1940a75f54da2e4">00527</a>     <span class="keywordtype">void</span> <a class="code" href="struct_alpha_num_validator.html#a3f4f3ccd9c334a41b1940a75f54da2e4">Reset</a>() {}
<a name="l00528"></a>00528 };
<a name="l00529"></a>00529 
<a name="l00532"></a><a class="code" href="struct_first_alpha_num_validator.html">00532</a> <span class="keyword">struct </span><a class="code" href="struct_first_alpha_num_validator.html" title="Validator for alphanumeric string starting with an alphabetical character.">FirstAlphaNumValidator</a>
<a name="l00533"></a>00533 {
<a name="l00540"></a><a class="code" href="struct_first_alpha_num_validator.html#ad4bf77991ec9a92dea4876748b12dd97">00540</a>     <span class="keywordtype">bool</span> <a class="code" href="struct_first_alpha_num_validator.html#ad4bf77991ec9a92dea4876748b12dd97">Validate</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; s, <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> newChar )<span class="keyword"> const</span>
<a name="l00541"></a>00541 <span class="keyword">    </span>{
<a name="l00542"></a>00542         <span class="keywordflow">return</span> s.empty() ? <a class="code" href="types_8h.html#a841b388b117fa23546c9cff87829295e">::IsAlpha</a>( newChar ) != 0 || <a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">::IsDigit</a>( newChar ) != 0
<a name="l00543"></a>00543             : <a class="code" href="types_8h.html#a841b388b117fa23546c9cff87829295e">::IsAlpha</a>( *s.begin() ) != 0 &amp;&amp; 
<a name="l00544"></a>00544               ( ::<a class="code" href="types_8h.html#a841b388b117fa23546c9cff87829295e">IsAlpha</a>( newChar ) != 0 || <a class="code" href="types_8h.html#a01b417a1f645aad1cfaf5aa520688fb4">::IsDigit</a>( newChar ) != 0 );
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546     
<a name="l00547"></a><a class="code" href="struct_first_alpha_num_validator.html#a74e55e1bcde63d8edc61dba48ce6d477">00547</a>     <span class="keywordtype">void</span> <a class="code" href="struct_first_alpha_num_validator.html#a74e55e1bcde63d8edc61dba48ce6d477">Reset</a>() {}
<a name="l00548"></a>00548 };
<a name="l00549"></a>00549 
<a name="l00554"></a><a class="code" href="class_const_string_validator.html">00554</a> <span class="keyword">class </span><a class="code" href="class_const_string_validator.html" title="Validates a constant string with support for case-insensitive validation.">ConstStringValidator</a>
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556 <span class="keyword">public</span>:
<a name="l00560"></a><a class="code" href="class_const_string_validator.html#a64ced17b6495ddaeff749ed46a58dfa2">00560</a>     <a class="code" href="class_const_string_validator.html#a41dda50ea058da17080f21c80713068d">ConstStringValidator</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; s, <span class="keywordtype">bool</span> ignoreCase = <span class="keyword">false</span> )
<a name="l00561"></a>00561         : <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>( s ), <a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a>( ignoreCase ), <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>( 0 ) {}
<a name="l00562"></a><a class="code" href="class_const_string_validator.html#a41dda50ea058da17080f21c80713068d">00562</a>     <a class="code" href="class_const_string_validator.html#a41dda50ea058da17080f21c80713068d">ConstStringValidator</a>() : <a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a>( false ), <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>( 0 ) {}
<a name="l00563"></a><a class="code" href="class_const_string_validator.html#a8e4a42983b8523473db4a136a5d61065">00563</a>     <a class="code" href="class_const_string_validator.html#a41dda50ea058da17080f21c80713068d">ConstStringValidator</a>( <span class="keyword">const</span> <a class="code" href="class_const_string_validator.html" title="Validates a constant string with support for case-insensitive validation.">ConstStringValidator</a>&amp; csv )
<a name="l00564"></a>00564         : <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>( csv.<a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a> ), <a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a>( csv.<a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a> ), <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>( csv.<a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a> ) {}
<a name="l00575"></a><a class="code" href="class_const_string_validator.html#aa2ad27b371c269e8a0b0d89504422383">00575</a>     <span class="keywordtype">bool</span> <a class="code" href="class_const_string_validator.html#aa2ad27b371c269e8a0b0d89504422383">Validate</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; , <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> newChar )<span class="keyword"> const</span>
<a name="l00576"></a>00576 <span class="keyword">    </span>{
<a name="l00577"></a>00577         <span class="keywordflow">if</span>( <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a> &gt;= <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>.length() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00578"></a>00578         <span class="keywordflow">if</span>( <a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a> ) <a class="code" href="types_8h.html#a07dacb88900a76706f6f0ec3c1266fd7">return ::ToLower</a>( <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>[ <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>++ ] ) == <a class="code" href="types_8h.html#a07dacb88900a76706f6f0ec3c1266fd7">::ToLower</a>( newChar );
<a name="l00579"></a>00579         <span class="keywordflow">return</span> <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>[ <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>++ ] == newChar;
<a name="l00580"></a>00580     }
<a name="l00582"></a><a class="code" href="class_const_string_validator.html#a7f4baf4318c2fc60a94809edc7fa3411">00582</a>     <span class="keywordtype">void</span> <a class="code" href="class_const_string_validator.html#a7f4baf4318c2fc60a94809edc7fa3411" title="Resets internal character index.">Reset</a>() { <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a> = 0; }
<a name="l00583"></a>00583 <span class="keyword">private</span>:
<a name="l00585"></a><a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1">00585</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_const_string_validator.html#a7a55b264ba491791ecb84ae95f082fb1" title="Constant string value.">value_</a>;
<a name="l00587"></a><a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695">00587</a>     <span class="keywordtype">bool</span> <a class="code" href="class_const_string_validator.html#ae2b9b33515b79262bda78ec479b5d695" title="Ignore case flag.">ignoreCase_</a>;
<a name="l00589"></a><a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39">00589</a>     <span class="keyword">mutable</span> String::size_type <a class="code" href="class_const_string_validator.html#a76b6c9d698b0b392d431f80e0a0b8d39" title="Index pointing at the next character to validate in ConstStringValidator::value_.">count_</a>;
<a name="l00590"></a>00590 };
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 
<a name="l00605"></a>00605 <span class="keyword">template</span> &lt; <span class="keyword">class</span> Val<span class="keywordtype">id</span>atorT = AlphaNumVal<span class="keywordtype">id</span>ator &gt;
<a name="l00606"></a><a class="code" href="class_sequence_parser.html">00606</a> <span class="keyword">class </span><a class="code" href="class_sequence_parser.html" title="Parser for strings.">SequenceParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608 <span class="keyword">public</span>:
<a name="l00609"></a><a class="code" href="class_sequence_parser.html#a11f64393ea33d689b2d34377e928d47d">00609</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_sequence_parser.html#a11f64393ea33d689b2d34377e928d47d" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00610"></a><a class="code" href="class_sequence_parser.html#add0928145e6e322fe1b72d0520a1d572">00610</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_sequence_parser.html#add0928145e6e322fe1b72d0520a1d572" title="Value type in map.">ValueType</a>;
<a name="l00611"></a><a class="code" href="class_sequence_parser.html#ad70c3d9da9fccc03d83c77f759242868">00611</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_sequence_parser.html#ad70c3d9da9fccc03d83c77f759242868" title="Key type in map.">KeyType</a>;
<a name="l00612"></a><a class="code" href="class_sequence_parser.html#af10f505b92efd2cf0aca5f2c97fec5ad">00612</a>     <span class="keyword">typedef</span> <a class="code" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a> <a class="code" href="class_sequence_parser.html#af10f505b92efd2cf0aca5f2c97fec5ad">Char</a>;
<a name="l00613"></a><a class="code" href="class_sequence_parser.html#a106d869c6502754c17a9801327469509">00613</a>     <span class="keyword">typedef</span> ValidatorT <a class="code" href="class_sequence_parser.html#a106d869c6502754c17a9801327469509">Validator</a>;
<a name="l00618"></a>00618     <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt;
<a name="l00619"></a><a class="code" href="class_sequence_parser.html#ad4fdc013a02853c14a123ef8f0e2211e">00619</a>     <a class="code" href="class_sequence_parser.html#ad4fdc013a02853c14a123ef8f0e2211e">SequenceParser</a>( <span class="keyword">const</span> <a class="code" href="class_tuple_parser.html">T</a>&amp; v, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a>( v ), <a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a>( name ) {} 
<a name="l00622"></a><a class="code" href="class_sequence_parser.html#a45e1e780fe0b974caa4f37d83457044d">00622</a>     <a class="code" href="class_sequence_parser.html#a45e1e780fe0b974caa4f37d83457044d">SequenceParser</a>( <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a>( name ) {}
<a name="l00624"></a><a class="code" href="class_sequence_parser.html#a8628dc5ca36276b267618e0cfe61ee45">00624</a>     <a class="code" href="class_sequence_parser.html#ad4fdc013a02853c14a123ef8f0e2211e">SequenceParser</a>( <span class="keyword">const</span> <a class="code" href="class_sequence_parser.html" title="Parser for strings.">SequenceParser</a>&amp; l ) 
<a name="l00625"></a>00625         : <a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a>( l.<a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a> ), <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>( l.<a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a> ), <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>( l.<a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a> ), <a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a>( l.<a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a> ) {}
<a name="l00627"></a><a class="code" href="class_sequence_parser.html#a8c1d1fd00789b9e47a29785ad8acf96b">00627</a>     <span class="keywordtype">bool</span> <a class="code" href="class_sequence_parser.html#a8c1d1fd00789b9e47a29785ad8acf96b" title="Overridden IParser::Parse method.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629         <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>.clear();
<a name="l00630"></a>00630         <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>.clear();
<a name="l00631"></a>00631         <a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a>.Reset();
<a name="l00632"></a>00632         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00633"></a>00633         <a class="code" href="class_sequence_parser.html#af10f505b92efd2cf0aca5f2c97fec5ad">Char</a> c = 0;
<a name="l00634"></a>00634         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() )
<a name="l00635"></a>00635         {
<a name="l00636"></a>00636             c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00637"></a>00637             <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() || !<a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a>.Validate( <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>, c ) ) <span class="keywordflow">break</span>;
<a name="l00638"></a>00638             <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>.push_back( c );
<a name="l00639"></a>00639         }
<a name="l00640"></a>00640         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00641"></a>00641         <span class="keywordflow">return</span> <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>.length() &gt; 0;
<a name="l00642"></a>00642     }
<a name="l00644"></a><a class="code" href="class_sequence_parser.html#a7e6c1fb2fd264755462dc58afa6c6485">00644</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_sequence_parser.html#a7e6c1fb2fd264755462dc58afa6c6485" title="Overridden IParser::GetValues method.">GetValues</a>()<span class="keyword"> const</span>
<a name="l00645"></a>00645 <span class="keyword">    </span>{
<a name="l00646"></a>00646         <span class="keywordflow">if</span>( <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>.empty() &amp; !<a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>.empty() )
<a name="l00647"></a>00647         {
<a name="l00648"></a>00648             <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a>, <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a> ) );
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650         <span class="keywordflow">return</span> <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>;
<a name="l00651"></a>00651     }
<a name="l00653"></a><a class="code" href="class_sequence_parser.html#ac9061193472c7c346ff10675dbe5863b">00653</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_sequence_parser.html#ac9061193472c7c346ff10675dbe5863b" title="Overridden IParser::operator[] .">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00654"></a>00654 <span class="keyword">    </span>{
<a name="l00655"></a>00655         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_sequence_parser.html#a7e6c1fb2fd264755462dc58afa6c6485" title="Overridden IParser::GetValues method.">GetValues</a>();
<a name="l00656"></a>00656         Values::const_iterator i = v.find( k );
<a name="l00657"></a>00657         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00658"></a>00658         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00659"></a>00659     }
<a name="l00661"></a><a class="code" href="class_sequence_parser.html#af91c50b1e23ea2ed5393efd27bd20ff8">00661</a>     <a class="code" href="class_sequence_parser.html" title="Parser for strings.">SequenceParser</a>* <a class="code" href="class_sequence_parser.html#af91c50b1e23ea2ed5393efd27bd20ff8" title="Overridden IParser::Clone method.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_sequence_parser.html#ad4fdc013a02853c14a123ef8f0e2211e">SequenceParser</a>( *<span class="keyword">this</span> ); }   
<a name="l00663"></a><a class="code" href="class_sequence_parser.html#afa66ac2c6e3848b963c5b7fe46c69d75">00663</a>     <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; <a class="code" href="class_sequence_parser.html#afa66ac2c6e3848b963c5b7fe46c69d75">GetText</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>; }
<a name="l00664"></a>00664 <span class="keyword">private</span>:
<a name="l00666"></a><a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0">00666</a>     <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> <a class="code" href="class_sequence_parser.html#ab13194809b25eeaac4079a68956fb7b0" title="Name associated to retrieved value(s); set as key in value map.">name_</a>;
<a name="l00668"></a><a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914">00668</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_sequence_parser.html#ad566d99b2fd7d48f53c906b65c643914" title="Parsed text.">token_</a>;
<a name="l00670"></a><a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02">00670</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_sequence_parser.html#ad7a499e5303c8cfa2f0cca9a08f03b02" title="Parsed values.">valueMap_</a>;
<a name="l00672"></a><a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a">00672</a>     <a class="code" href="class_const_string_validator.html" title="Validates a constant string with support for case-insensitive validation.">Validator</a> <a class="code" href="class_sequence_parser.html#a7de7940dd7fa8bb5e580e2f0d2ae2b1a" title="Validator used by SequenceParser::Parse method to validate input.">validator_</a>;
<a name="l00673"></a>00673 };
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00680"></a><a class="code" href="class_const_string_parser.html">00680</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_const_string_parser.html" title="Convenience class that implements a parser for constant strings.">ConstStringParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682 <span class="keyword">public</span>:
<a name="l00683"></a><a class="code" href="class_const_string_parser.html#aa202f66eccdefbea8376e06c0e32f947">00683</a>     <a class="code" href="class_const_string_parser.html#aa202f66eccdefbea8376e06c0e32f947">ConstStringParser</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; s, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>(), <span class="keywordtype">bool</span> ignoreCase = <span class="keyword">true</span> ) :
<a name="l00684"></a>00684       <a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">csv_</a>( <a class="code" href="class_const_string_validator.html" title="Validates a constant string with support for case-insensitive validation.">ConstStringValidator</a>( s, ignoreCase ), name ) {}
<a name="l00685"></a><a class="code" href="class_const_string_parser.html#ac8b174449c9dcffeb80f03f927356942">00685</a>     <span class="keywordtype">bool</span> <a class="code" href="class_const_string_parser.html#ac8b174449c9dcffeb80f03f927356942" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) { <span class="keywordflow">return</span> <a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">csv_</a>.<a class="code" href="class_sequence_parser.html#a8c1d1fd00789b9e47a29785ad8acf96b" title="Overridden IParser::Parse method.">Parse</a>( is ); }
<a name="l00686"></a><a class="code" href="class_const_string_parser.html#a2ae44bd105f03319fafe322f12c6fede">00686</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_const_string_parser.html#a2ae44bd105f03319fafe322f12c6fede">GetValues</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">csv_</a>.<a class="code" href="class_sequence_parser.html#a7e6c1fb2fd264755462dc58afa6c6485" title="Overridden IParser::GetValues method.">GetValues</a>(); }
<a name="l00687"></a><a class="code" href="class_const_string_parser.html#ab131d8f0d55c05d6cdb582d58518fe86">00687</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_const_string_parser.html#ab131d8f0d55c05d6cdb582d58518fe86">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">csv_</a>[ k ]; }
<a name="l00688"></a><a class="code" href="class_const_string_parser.html#ad63c92351aea60cd2ca1d32eb0d7be44">00688</a>     <a class="code" href="class_const_string_parser.html" title="Convenience class that implements a parser for constant strings.">ConstStringParser</a>* <a class="code" href="class_const_string_parser.html#ad63c92351aea60cd2ca1d32eb0d7be44">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_const_string_parser.html#aa202f66eccdefbea8376e06c0e32f947">ConstStringParser</a>( *<span class="keyword">this</span> ); } 
<a name="l00689"></a>00689 <span class="keyword">private</span>:
<a name="l00690"></a><a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">00690</a>     <a class="code" href="class_sequence_parser.html">SequenceParser&lt; ConstStringValidator &gt;</a> <a class="code" href="class_const_string_parser.html#a0aeb38bfbde849ef007549a33b8fb6a6">csv_</a>;
<a name="l00691"></a>00691 };
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00698"></a><a class="code" href="class_alpha_num_parser.html">00698</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_alpha_num_parser.html" title="Convenience class that implements a parser for alphanumeric strings.">AlphaNumParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700 <span class="keyword">public</span>:
<a name="l00701"></a><a class="code" href="class_alpha_num_parser.html#accdfaa049849a71b4d31b292d28722dc">00701</a>     <a class="code" href="class_alpha_num_parser.html#accdfaa049849a71b4d31b292d28722dc">AlphaNumParser</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; name ) : <a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">anl_</a>( name ) {}
<a name="l00702"></a><a class="code" href="class_alpha_num_parser.html#a51eeefe5a3b946f00d00d06830255665">00702</a>     <span class="keywordtype">bool</span> <a class="code" href="class_alpha_num_parser.html#a51eeefe5a3b946f00d00d06830255665" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is ) { <span class="keywordflow">return</span> <a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">anl_</a>.<a class="code" href="class_sequence_parser.html#a8c1d1fd00789b9e47a29785ad8acf96b" title="Overridden IParser::Parse method.">Parse</a>( is ); }
<a name="l00703"></a><a class="code" href="class_alpha_num_parser.html#a6d570923424b4b9e11b46ba0603f82bb">00703</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_alpha_num_parser.html#a6d570923424b4b9e11b46ba0603f82bb">GetValues</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">anl_</a>.<a class="code" href="class_sequence_parser.html#a7e6c1fb2fd264755462dc58afa6c6485" title="Overridden IParser::GetValues method.">GetValues</a>(); }
<a name="l00704"></a><a class="code" href="class_alpha_num_parser.html#a1c6909d7ce14f38a915ffc0fe74478ef">00704</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_alpha_num_parser.html#a1c6909d7ce14f38a915ffc0fe74478ef">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">anl_</a>[ k ]; }
<a name="l00705"></a><a class="code" href="class_alpha_num_parser.html#a17a7e1628bf436821c6e5b81a73ce429">00705</a>     <a class="code" href="class_alpha_num_parser.html" title="Convenience class that implements a parser for alphanumeric strings.">AlphaNumParser</a>* <a class="code" href="class_alpha_num_parser.html#a17a7e1628bf436821c6e5b81a73ce429">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_alpha_num_parser.html#accdfaa049849a71b4d31b292d28722dc">AlphaNumParser</a>( *<span class="keyword">this</span> ); }
<a name="l00706"></a>00706 <span class="keyword">private</span>:
<a name="l00707"></a><a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">00707</a>     <a class="code" href="class_sequence_parser.html">SequenceParser&lt; AlphaNumValidator &gt;</a> <a class="code" href="class_alpha_num_parser.html#aca406184a5343a5e411cdabd54eebb7d">anl_</a>;
<a name="l00708"></a>00708 };
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00717"></a><a class="code" href="class_first_alpha_num_parser.html">00717</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_first_alpha_num_parser.html" title="Convenience class that implements a parser for alphanumeric strings that start with a letter...">FirstAlphaNumParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719 <span class="keyword">public</span>:
<a name="l00720"></a><a class="code" href="class_first_alpha_num_parser.html#adb43e5431672bff98eeb373b423b7ccb">00720</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_first_alpha_num_parser.html#adb43e5431672bff98eeb373b423b7ccb" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00721"></a><a class="code" href="class_first_alpha_num_parser.html#ae032293b3603eda3f0d4c5c2ea875ccc">00721</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_first_alpha_num_parser.html#ae032293b3603eda3f0d4c5c2ea875ccc" title="Value type in map.">ValueType</a>;
<a name="l00722"></a><a class="code" href="class_first_alpha_num_parser.html#a8c9b4593160fb9708fdbfb0c47be9b2a">00722</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_first_alpha_num_parser.html#a8c9b4593160fb9708fdbfb0c47be9b2a" title="Key type in map.">KeyType</a>;
<a name="l00725"></a><a class="code" href="class_first_alpha_num_parser.html#a0e38b98eb610ce98788239f5ae9bf9d1">00725</a>     <a class="code" href="class_first_alpha_num_parser.html#a0e38b98eb610ce98788239f5ae9bf9d1">FirstAlphaNumParser</a>( <span class="keyword">const</span> <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&amp; name ) : <a class="code" href="class_first_alpha_num_parser.html#a3645d28626b4fb1669b26128a8ff31ce">name_</a>( name ) {}
<a name="l00728"></a><a class="code" href="class_first_alpha_num_parser.html#aa0a510e3e00ea6a9f112b75c401afbcc">00728</a>     <span class="keywordtype">bool</span> <a class="code" href="class_first_alpha_num_parser.html#aa0a510e3e00ea6a9f112b75c401afbcc">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00729"></a>00729     { 
<a name="l00730"></a>00730         <a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">token_</a>.clear();
<a name="l00731"></a>00731         <a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">valueMap_</a>.clear();
<a name="l00732"></a>00732         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00733"></a>00733         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00734"></a>00734         <span class="keywordflow">if</span>( ::<a class="code" href="types_8h.html#a841b388b117fa23546c9cff87829295e">IsAlpha</a>( c ) != 0 )
<a name="l00735"></a>00735         {
<a name="l00736"></a>00736             <a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">token_</a> += c;
<a name="l00737"></a>00737             <span class="keywordflow">if</span>( <a class="code" href="class_first_alpha_num_parser.html#a5448c3d75214dd6a43694d27c0cca799">anl_</a>.<a class="code" href="class_sequence_parser.html#a8c1d1fd00789b9e47a29785ad8acf96b" title="Overridden IParser::Parse method.">Parse</a>( is ) )
<a name="l00738"></a>00738             {
<a name="l00739"></a>00739                 <a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">token_</a> += <a class="code" href="class_first_alpha_num_parser.html#a5448c3d75214dd6a43694d27c0cca799">anl_</a>.<a class="code" href="class_sequence_parser.html#afa66ac2c6e3848b963c5b7fe46c69d75">GetText</a>();
<a name="l00740"></a>00740             }
<a name="l00741"></a>00741             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743         is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00744"></a>00744         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00745"></a>00745     }
<a name="l00747"></a><a class="code" href="class_first_alpha_num_parser.html#aee1724ed2e6f44b3a2d9b21198160339">00747</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_first_alpha_num_parser.html#aee1724ed2e6f44b3a2d9b21198160339" title="IParser::GetValues implementation.">GetValues</a>()<span class="keyword"> const</span>
<a name="l00748"></a>00748 <span class="keyword">    </span>{
<a name="l00749"></a>00749         <span class="keywordflow">if</span>( <a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">valueMap_</a>.empty() ) <a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_first_alpha_num_parser.html#a3645d28626b4fb1669b26128a8ff31ce">name_</a>, <a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">token_</a> ) );
<a name="l00750"></a>00750         <span class="keywordflow">return</span> <a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">valueMap_</a>;
<a name="l00751"></a>00751     }
<a name="l00753"></a><a class="code" href="class_first_alpha_num_parser.html#a9f0c4b37c90aef3387be7f7798e836ee">00753</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_first_alpha_num_parser.html#a9f0c4b37c90aef3387be7f7798e836ee" title="IParser::operator[] implementation.">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00754"></a>00754 <span class="keyword">    </span>{
<a name="l00755"></a>00755         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_first_alpha_num_parser.html#aee1724ed2e6f44b3a2d9b21198160339" title="IParser::GetValues implementation.">GetValues</a>();
<a name="l00756"></a>00756         Values::const_iterator i = v.find( k );
<a name="l00757"></a>00757         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00758"></a>00758         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00759"></a>00759     }
<a name="l00761"></a><a class="code" href="class_first_alpha_num_parser.html#a9ede438afbb0c612ebc88a33afd5c19f">00761</a>     <a class="code" href="class_first_alpha_num_parser.html" title="Convenience class that implements a parser for alphanumeric strings that start with a letter...">FirstAlphaNumParser</a>* <a class="code" href="class_first_alpha_num_parser.html#a9ede438afbb0c612ebc88a33afd5c19f" title="IParser::Clone implementation.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_first_alpha_num_parser.html#a0e38b98eb610ce98788239f5ae9bf9d1">FirstAlphaNumParser</a>( *<span class="keyword">this</span> ); } 
<a name="l00762"></a>00762 <span class="keyword">private</span>:
<a name="l00763"></a><a class="code" href="class_first_alpha_num_parser.html#a3645d28626b4fb1669b26128a8ff31ce">00763</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_first_alpha_num_parser.html#a3645d28626b4fb1669b26128a8ff31ce">name_</a>;
<a name="l00764"></a><a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">00764</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_first_alpha_num_parser.html#acd83e92f6fcb8887f11ac97f02534ed6">token_</a>;
<a name="l00765"></a><a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">00765</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_first_alpha_num_parser.html#a236370db2266668f3ed80a93c050f4e4">valueMap_</a>;
<a name="l00766"></a><a class="code" href="class_first_alpha_num_parser.html#a5448c3d75214dd6a43694d27c0cca799">00766</a>     <a class="code" href="class_sequence_parser.html">SequenceParser&lt; AlphaNumValidator &gt;</a> <a class="code" href="class_first_alpha_num_parser.html#a5448c3d75214dd6a43694d27c0cca799">anl_</a>;
<a name="l00767"></a>00767 };
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00773"></a>00773 <span class="comment"></span><span class="keyword">template</span> &lt; <span class="keywordtype">int</span> SIZE = -1 &gt; <span class="comment">// </span>
<a name="l00774"></a><a class="code" href="class_tuple_parser.html">00774</a> <span class="keyword">class </span><a class="code" href="class_tuple_parser.html" title="Parser for sequences of values of the same type separated by a separator expression and bound with a ...">TupleParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00775"></a>00775 {
<a name="l00776"></a>00776 <span class="keyword">public</span>:
<a name="l00777"></a><a class="code" href="class_tuple_parser.html#a158511e3d111e2e02ccecd8d223d955e">00777</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_tuple_parser.html#a158511e3d111e2e02ccecd8d223d955e" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00778"></a><a class="code" href="class_tuple_parser.html#a1b83774c0c961ea9284b9379c1b39a56">00778</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_tuple_parser.html#a1b83774c0c961ea9284b9379c1b39a56" title="Value type in map.">ValueType</a>;
<a name="l00779"></a><a class="code" href="class_tuple_parser.html#aca9a2f84c5b149070bd4292108f71085">00779</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_tuple_parser.html#aca9a2f84c5b149070bd4292108f71085" title="Key type in map.">KeyType</a>;
<a name="l00780"></a><a class="code" href="class_tuple_parser.html#a40f5768d2e3032cb06074219c1d4e013">00780</a>     <span class="keyword">typedef</span> <a class="code" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a> <a class="code" href="class_tuple_parser.html#a40f5768d2e3032cb06074219c1d4e013">Char</a>;
<a name="l00781"></a><a class="code" href="class_tuple_parser.html#a1de985101197cc429c35a386aa1afc50">00781</a>     <span class="keyword">typedef</span> std::list&lt; Parser &gt; <a class="code" href="class_tuple_parser.html#a1de985101197cc429c35a386aa1afc50">Parsers</a>;
<a name="l00782"></a><a class="code" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">00782</a>     <a class="code" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">TupleParser</a>() {}
<a name="l00790"></a><a class="code" href="class_tuple_parser.html#a3c5a22e7c6f3520bc9f3e1c2d722a8c6">00790</a>     <a class="code" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">TupleParser</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; v, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>(), <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; b = <a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a>(),
<a name="l00791"></a>00791         <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; s = <a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a>(), <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; e = <a class="code" href="class_blank_parser.html" title="Parse blanks.">BlankParser</a>(), <span class="keywordtype">bool</span> blanks = <span class="keyword">false</span> ) : <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a>( blanks ),
<a name="l00792"></a>00792         <a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d" title="Parser that identifies the start of the tuple.">beginParser_</a>( b ), <a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a>( v ), <a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887" title="Parser that parses the expression separating two adjacent values.">separatorParser_</a>( s ), <a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca" title="Parser that parses the expression identifying the end of the tuple.">endParser_</a>( e ), <a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2" title="Name assigned to values in value map.">name_</a>( name ) {}
<a name="l00793"></a><a class="code" href="class_tuple_parser.html#a843fd3e26af770a75905b1f71e907a93">00793</a>     <a class="code" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">TupleParser</a>( <span class="keyword">const</span> <a class="code" href="class_tuple_parser.html" title="Parser for sequences of values of the same type separated by a separator expression and bound with a ...">TupleParser</a>&amp; l ) 
<a name="l00794"></a>00794         : <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a>( l.<a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a> ), <a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2" title="Name assigned to values in value map.">name_</a>( l.<a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2" title="Name assigned to values in value map.">name_</a> ), <a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d" title="Parser that identifies the start of the tuple.">beginParser_</a>( l.<a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d" title="Parser that identifies the start of the tuple.">beginParser_</a> ), 
<a name="l00795"></a>00795           <a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a>( l.<a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a> ), <a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887" title="Parser that parses the expression separating two adjacent values.">separatorParser_</a>( l.<a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887" title="Parser that parses the expression separating two adjacent values.">separatorParser_</a> ),
<a name="l00796"></a>00796         <a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca" title="Parser that parses the expression identifying the end of the tuple.">endParser_</a>( l.<a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca" title="Parser that parses the expression identifying the end of the tuple.">endParser_</a> ), <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>( l.<a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a> ), <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>( l.<a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a> )
<a name="l00797"></a>00797     {}
<a name="l00802"></a><a class="code" href="class_tuple_parser.html#a6a4d8d3284fc040fb51b9005c92f8b8a">00802</a>     <span class="keywordtype">bool</span> <a class="code" href="class_tuple_parser.html#a6a4d8d3284fc040fb51b9005c92f8b8a">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00803"></a>00803     {
<a name="l00804"></a>00804         <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>.clear();
<a name="l00805"></a>00805         <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>.clear();
<a name="l00806"></a>00806         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00807"></a>00807         <span class="keywordtype">int</span> counter = 0;
<a name="l00808"></a>00808         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00809"></a>00809         {
<a name="l00810"></a>00810         <span class="comment">// record current file pointer and rewind when exiting scope in case</span>
<a name="l00811"></a>00811         <span class="comment">// parser not applied; nested scope required if local variable used</span>
<a name="l00812"></a>00812         <span class="comment">// as signal</span>
<a name="l00813"></a>00813         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00814"></a>00814         <span class="comment">// apply begin parser and return false if it fails</span>
<a name="l00815"></a>00815         <span class="keywordflow">if</span>( <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a> ) <a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b" title="Advances to first non-blank character or EOF.">SkipBlanks</a>( is );
<a name="l00816"></a>00816         <span class="keywordflow">if</span>( !<a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d" title="Parser that identifies the start of the tuple.">beginParser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00817"></a>00817         <span class="keywordtype">bool</span> endReached = <span class="keyword">false</span>;
<a name="l00818"></a>00818         std::vector&lt; ValueType &gt;::size_type s = 0;
<a name="l00819"></a>00819         <span class="comment">// start applying value parser</span>
<a name="l00820"></a>00820         <span class="keywordflow">if</span>( <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a> ) <a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b" title="Advances to first non-blank character or EOF.">SkipBlanks</a>( is );
<a name="l00821"></a>00821         <span class="keywordflow">while</span>(  <a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is ) )
<a name="l00822"></a>00822         {
<a name="l00823"></a>00823             <span class="comment">// parsed values: add values to value array</span>
<a name="l00824"></a>00824             <span class="comment">/*s =*/</span> <a class="code" href="class_tuple_parser.html#a5febe8abe029c13d93aaf44fc0b66e38" title="Adds value to parsed value array.">AddValue</a>( <a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a>.<a class="code" href="class_parser.html#ac0c1b0eb6d22fb1b9c4b9f7a542c6ae2" title="Implementation of IParser::GetValues.">GetValues</a>() );
<a name="l00825"></a>00825             <span class="comment">// increment value counter</span>
<a name="l00826"></a>00826             ++counter;
<a name="l00827"></a>00827             <span class="comment">// apply separator parser and exit loop if it fails</span>
<a name="l00828"></a>00828             <span class="keywordflow">if</span>( !<a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887" title="Parser that parses the expression separating two adjacent values.">separatorParser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is ) ) <span class="keywordflow">break</span>;
<a name="l00829"></a>00829             <span class="comment">// value &amp; separator parser applied, if required skip blanks before next value or</span>
<a name="l00830"></a>00830             <span class="comment">// end separator</span>
<a name="l00831"></a>00831             <span class="keywordflow">if</span>( <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a> ) <a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b" title="Advances to first non-blank character or EOF.">SkipBlanks</a>( is );
<a name="l00832"></a>00832         }
<a name="l00833"></a>00833         <span class="comment">// exited from loop: either end separator or wrong expression found  </span>
<a name="l00834"></a>00834         
<a name="l00835"></a>00835         <span class="comment">// apply end separator: if it succeeds it means the end separator was</span>
<a name="l00836"></a>00836         <span class="comment">// parsed successfully and the end of the tuple was reached</span>
<a name="l00837"></a>00837         <span class="keywordflow">if</span>( <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a> ) <a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b" title="Advances to first non-blank character or EOF.">SkipBlanks</a>( is );
<a name="l00838"></a>00838         endReached = <a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca" title="Parser that parses the expression identifying the end of the tuple.">endParser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is );
<a name="l00839"></a>00839         
<a name="l00840"></a>00840         <span class="comment">// if end reached and number of parsed values is correct return true, false</span>
<a name="l00841"></a>00841         <span class="comment">// otherwhise</span>
<a name="l00842"></a>00842         ok = endReached &amp;&amp; ( counter == <a class="code" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">Size</a>() || ( counter &gt; 0 &amp;&amp; <a class="code" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">Size</a>() &lt; 0 ) );
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844         <span class="keywordflow">return</span> ok;
<a name="l00845"></a>00845     }
<a name="l00847"></a><a class="code" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">00847</a>     <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">Size</a>() { <span class="keywordflow">return</span> SIZE; }
<a name="l00849"></a><a class="code" href="class_tuple_parser.html#a35eb5a182a0d3ee1517ca9cd096841c5">00849</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_tuple_parser.html#a35eb5a182a0d3ee1517ca9cd096841c5" title="IParser::GetValues implementation.">GetValues</a>()<span class="keyword"> const</span>
<a name="l00850"></a>00850 <span class="keyword">    </span>{
<a name="l00851"></a>00851         <span class="keywordflow">if</span>( <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>.empty() &amp;&amp; !<a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>.empty() )
<a name="l00852"></a>00852         {
<a name="l00853"></a>00853             <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2" title="Name assigned to values in value map.">name_</a>, <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a> ) );
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855         <span class="keywordflow">return</span> <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>;
<a name="l00856"></a>00856     }
<a name="l00858"></a><a class="code" href="class_tuple_parser.html#adaa18884a8b46eacb40e81f90e5e7f11">00858</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_tuple_parser.html#adaa18884a8b46eacb40e81f90e5e7f11" title="IParser::operator[] implementation.">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00859"></a>00859 <span class="keyword">    </span>{
<a name="l00860"></a>00860         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_tuple_parser.html#a35eb5a182a0d3ee1517ca9cd096841c5" title="IParser::GetValues implementation.">GetValues</a>();
<a name="l00861"></a>00861         Values::const_iterator i = v.find( k );
<a name="l00862"></a>00862         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00863"></a>00863         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00864"></a>00864     }
<a name="l00866"></a><a class="code" href="class_tuple_parser.html#acc78611f9497736c3ff5c7846ae9338a">00866</a>     <a class="code" href="class_tuple_parser.html" title="Parser for sequences of values of the same type separated by a separator expression and bound with a ...">TupleParser</a>* <a class="code" href="class_tuple_parser.html#acc78611f9497736c3ff5c7846ae9338a" title="IParser::Clone implementation.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">TupleParser</a>( *<span class="keyword">this</span> ); } 
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="keyword">private</span>:
<a name="l00870"></a><a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b">00870</a>     <span class="keywordtype">void</span> <a class="code" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b" title="Advances to first non-blank character or EOF.">SkipBlanks</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00871"></a>00871     {
<a name="l00872"></a>00872         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() )
<a name="l00873"></a>00873         {
<a name="l00874"></a>00874             <a class="code" href="class_tuple_parser.html#a40f5768d2e3032cb06074219c1d4e013">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00875"></a>00875             <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="types_8h.html#a1f9b22c3625387791aa9814dddd995dd">::IsSpace</a>( c ) != 0  ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00876"></a>00876             <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00877"></a>00877         }
<a name="l00878"></a>00878     }
<a name="l00879"></a>00879 
<a name="l00881"></a><a class="code" href="class_tuple_parser.html#a5febe8abe029c13d93aaf44fc0b66e38">00881</a>     std::vector&lt; ValueType &gt;::size_type <a class="code" href="class_tuple_parser.html#a5febe8abe029c13d93aaf44fc0b66e38" title="Adds value to parsed value array.">AddValue</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v )
<a name="l00882"></a>00882     {
<a name="l00883"></a>00883         std::vector&lt; ValueType &gt;::size_type bs = <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>.size();
<a name="l00884"></a>00884         <span class="keywordflow">for</span>( Values::const_iterator i = v.begin();
<a name="l00885"></a>00885              i != v.end();
<a name="l00886"></a>00886              ++i ) <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>.push_back( i-&gt;second );
<a name="l00887"></a>00887         <span class="keywordflow">return</span> <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>.size() - bs;
<a name="l00888"></a>00888     }
<a name="l00891"></a><a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">00891</a>     <span class="keywordtype">bool</span> <a class="code" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a>;
<a name="l00893"></a><a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2">00893</a>     <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="code" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2" title="Name assigned to values in value map.">name_</a>;
<a name="l00895"></a><a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d">00895</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d" title="Parser that identifies the start of the tuple.">beginParser_</a>;
<a name="l00897"></a><a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae">00897</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae" title="Parser that parses individual tuple components.">valueParser_</a>;
<a name="l00899"></a><a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887">00899</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887" title="Parser that parses the expression separating two adjacent values.">separatorParser_</a>;
<a name="l00901"></a><a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca">00901</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca" title="Parser that parses the expression identifying the end of the tuple.">endParser_</a>;
<a name="l00903"></a><a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa">00903</a>     std::vector&lt; ValueType &gt; <a class="code" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa" title="Parsed values.">values_</a>;
<a name="l00905"></a><a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97">00905</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97" title="Value map.">valueMap_</a>;
<a name="l00906"></a>00906 };
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 
<a name="l00927"></a><a class="code" href="class_pass_thru_parser.html">00927</a> <span class="keyword">class </span><a class="code" href="class_pass_thru_parser.html" title="Pass through parser: always validates the input.">PassThruParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00928"></a>00928 {
<a name="l00929"></a>00929 <span class="keyword">public</span>:
<a name="l00930"></a><a class="code" href="class_pass_thru_parser.html#a31d19c432769365a1a0e721c6bc008fd">00930</a>     <span class="keywordtype">bool</span> <a class="code" href="class_pass_thru_parser.html#a31d19c432769365a1a0e721c6bc008fd" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp;  ) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00931"></a><a class="code" href="class_pass_thru_parser.html#ab83bb0069e54c07d489a9d61180a0eb0">00931</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_pass_thru_parser.html#ab83bb0069e54c07d489a9d61180a0eb0">GetValues</a>()<span class="keyword"> const </span>{ <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> v; <span class="keywordflow">return</span> v; }
<a name="l00932"></a><a class="code" href="class_pass_thru_parser.html#a89565489baab7e532f12d16896cfa1a9">00932</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_pass_thru_parser.html#a89565489baab7e532f12d16896cfa1a9">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp;  )<span class="keyword"> const </span>{ <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a> v; <span class="keywordflow">return</span> v; }
<a name="l00933"></a><a class="code" href="class_pass_thru_parser.html#affa5bbc8b097052cac4aea65f5a03556">00933</a>     <a class="code" href="class_pass_thru_parser.html" title="Pass through parser: always validates the input.">PassThruParser</a>* <a class="code" href="class_pass_thru_parser.html#affa5bbc8b097052cac4aea65f5a03556">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_pass_thru_parser.html" title="Pass through parser: always validates the input.">PassThruParser</a>( *<span class="keyword">this</span> ); }   
<a name="l00934"></a>00934 };
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 <span class="preprocessor">#endif // LEXERS_H_</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon May 14 2012 09:53:26 for Parsley by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
