Searching 6 files for "\s+::" (regex)

/Users/uvaretto/projects/parsley/src/test/moldenformat.cpp:
  206      std::ifstream ifs2( "c:\\projects\\parsley\\data\\molden.input.win" );
  207  #else
  208:     std::string dir( ::getenv( "HOME" ) );
  209      std::string lpath = dir + "/projects/parsley/data/molden.input";
  210      std::string wpath = dir + "/projects/parsley/data/molden.input.win";

1 match in 1 file


Searching 12 files for "\s+::" (regex)

/Users/uvaretto/projects/parsley/include/Parser.h:
   87      /// Swap: swap internal pointers to IParser implementations.
   88      /// @return reference to @c *this after swap.
   89:     Parser& Swap( Parser& l ) { ::Swap( pImpl_, l.pImpl_ ); return *this; } 
   90      /// Assignment operator from other parser.
   91      Parser& operator=( const Parser& l ) { 
   ..
  263          if( !is.good() ) return;
  264          Char c = is.get();
  265:         while( is.good() && ::IsSpace( c ) != 0 ) c = is.get();
  266          if( is.good() ) is.unget();
  267      }

/Users/uvaretto/projects/parsley/include/ParserManager.h:
  123          : pImpl_( other.pImpl_ ? other.pImpl_->Clone() : 0 ) {}
  124      TransitionCBack( ITransitionCBack* ptr ) : pImpl_( ptr ) {}
  125:     TransitionCBack& Swap( TransitionCBack& v ) { 
  126:         ::Swap( pImpl_, v.pImpl_ ); return *this; 
  127      } 
  128      TransitionCBack& operator=( const TransitionCBack& v ) { 

/Users/uvaretto/projects/parsley/include/parsers.h:
   72  private:
   73      bool IsBlank( Char c ) const {
   74:         return ::IsSpace( c ) != 0 && c != '\n';
   75      }
   76      Char Eol() const { return '\n'; }
   ..
  103  private:
  104      bool IsBlank( Char c ) const {
  105:         return ::IsSpace( c ) != 0;
  106      }
  107  };
  ...
  162  private:
  163      bool IsBlank( Char c ) const {
  164:         return ::IsSpace( c ) != 0;
  165      }
  166  };
  ...
  209          Char c = is.get();
  210          if( !is.good() ) return false;
  211:         if( ::IsDigit( c ) == 0 ) {
  212              is.unget();
  213              return false;
  ...
  226              valueMap_.insert( 
  227                  std::make_pair( 
  228:                     name_, unsigned( ::ToInt( token_.c_str() ) ) ) );
  229          }
  230          return valueMap_;
  ...
  251          Char c = is.get();
  252          if( !is.good() ) return;
  253:         while( is.good() && ::IsDigit( c ) != 0 ) {
  254              token_.push_back( c );
  255              c = is.get();
  ...
  317              valueMap_.insert( 
  318                  std::make_pair( 
  319:                     name_, int( ::ToInt( token_.c_str() ) ) ) );
  320          }
  321          return valueMap_;
  ...
  391              }
  392          }
  393:         else if( ::IsDigit( c ) != 0 ) {
  394              is.unget();
  395              Apply( &FloatParser::MatchUnsigned, is, 0 );
  ...
  408              valueMap_.insert( 
  409                  std::make_pair( 
  410:                     name_, ::ToFloat( token_.c_str() ) ) );
  411          }
  412          return valueMap_;
  ...
  450          const Char c = is.get();
  451          if( !is.good() ) return false;
  452:         if( ::IsDigit( c ) != 0 ) { 
  453              token_.push_back( c ); 
  454              Apply( &FloatParser::MatchUnsigned, is, 0 ); 
  ...
  467          const Char c = is.get();
  468          if( !is.good() ) return false;
  469:         if( ::IsDigit( c ) ) {
  470              token_.push_back( c ); 
  471              Apply( &FloatParser::MatchFractional, is, 0 );
  ...
  491              return Apply( &FloatParser::MatchExponent, is, c );
  492          }
  493:         else if( ::IsDigit( c ) ) {
  494              token_.push_back( c ); 
  495              Apply( &FloatParser::MatchExponent, is,  0 ); 
  ...
  516      /// Validates any alphanumeric value
  517      bool Validate( const String&, Char newChar ) const {
  518:         return ::IsAlnum( newChar ) != 0;
  519      }
  520      
  ...
  533      /// the first character to be parsed.
  534      bool Validate( const String& s, Char newChar ) const {
  535:         return s.empty() ? 
  536:                ::IsAlpha( newChar ) != 0 || ::IsDigit( newChar ) != 0
  537:             : ::IsAlpha( *s.begin() ) != 0 && 
  538:               ( ::IsAlpha( newChar ) != 0 || ::IsDigit( newChar ) != 0 );
  539      }
  540      
  ...
  572          if( count_ >= value_.length() ) return false;
  573          if( ignoreCase_ ) {
  574:             return ::ToLower( value_[ count_++ ] ) == ::ToLower( newChar );
  575          }
  576          return value_[ count_++ ] == newChar;
  ...
  728          if( !is.good() ) return false;
  729          Char c = is.get();
  730:         if( ::IsAlpha( c ) != 0 ) {
  731              token_ += c;
  732              if( anl_.Parse( is ) ) {
  ...
  870          if( is.good() ) {
  871              Char c = is.get();
  872:             while( is.good() && ::IsSpace( c ) != 0  ) c = is.get();
  873              if( is.good() ) is.unget();
  874          }

/Users/uvaretto/projects/parsley/include/StateManager.h:
   86          : pImpl_( v.pImpl_ ? v.pImpl_->Clone() : 0 ) {}
   87      /// Swap.
   88:     StateManager& Swap( StateManager& v ) { 
   89:         ::Swap( pImpl_, v.pImpl_ ); return *this; 
   90      } 
   91      /// Assignment from StateManager.

/Users/uvaretto/projects/parsley/include/types.h:
   50  
   51  // wrappers useful for future unicode support
   52: inline double ToFloat( const char* str ) { return ::atof( str ); }
   53: inline int ToInt( const char* str ) { return ::atoi( str ); }
   54: inline int IsSpace( int c ) { return ::isspace( c ); }
   55: inline int ToLower( int c ) { return ::tolower( c ); }
   56: inline int IsAlpha( int c ) { return ::isalpha( c ); }
   57: inline int IsAlnum( int c ) { return ::isalnum( c ); }
   58: inline int IsDigit( int c ) { return ::isdigit( c ); }
   59  
   60  } //namespace

33 matches across 5 files
