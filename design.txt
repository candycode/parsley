
Parser ATOM_SECTION_HEADER =

  "ATOMIC_CENTER", !+ALPHA_NUM, "ATOMIC_ORBITAL", !+ALPHA_NUM, "GAUSSIA  FUNCTIONS", !+ALPHA_NUM, EOL_;

Parser SKIP = !(STRING, FLOAT, FLOAT, FLOAT);

Parser ATOM_COORD = (STRING("element"), FLOAT("x"), FLOAT("y", FLOAT("z");
               
Parser ORBITAL = !*ALNUM, (INT / (INT, '-', INT)("function #")), STRING("shell"), FLOAT("scaling"),
                 +(!*ALNUM, FLOAT("exponent"), FLOAT("s"), FLOAT("p"), FLOAT("d"), FLOAT("f"));

Parser atoms = ATOM_SECTION_HEADERS, SKIP, +(ATOM_COORD, ORBITAL);


"(1+2)*3";

value = FLOAT;

expr 

rexpr = expr

expr = "(", rexpr, ")"
/ value
/ "-", rexpr
/ "+", rexpr
/ rexpr, "*", rexpr
/ rexpr, "+", rexpr
/ rexpr, "-", rexpr
/ EOF

( -> new stacks 
value -> push on stack
*,+,- -> push on op stack
) or EOF evaluate content of stack and push value on stack

Visit


class Node {
	virtual void Eval(Stack& s, NodeList& next) 
}

ScopedNodeEval(N n, Val) {
    Val v = Eval[n.down.type()](n.down, Val());
    return Eval[n.next.type()](n.next, v);	
}

BinOpEval(N n, Val v) {
	return n.Apply(v, Eval[n.next.type()](n.next, Val()));
}









