<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Parsley: TupleParser&lt; SIZE &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Parsley
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">TupleParser&lt; SIZE &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___parsers.html">Parsers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="TupleParser" --><!-- doxytag: inherits="IParser" -->
<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> for sequences of values of the same type separated by a separator expression and bound with a start/end expression.  
 <a href="class_tuple_parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parsers_8h_source.html">parsers.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TupleParser&lt; SIZE &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_tuple_parser.png" usemap="#TupleParser&lt; SIZE &gt;_map" alt=""/>
  <map id="TupleParser&lt; SIZE &gt;_map" name="TupleParser&lt; SIZE &gt;_map">
<area href="struct_i_parser.html" title="interface for parsers." alt="IParser" shape="rect" coords="0,0,133,24"/>
</map>
 </div></div>

<p><a href="class_tuple_parser-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">IParser::Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a158511e3d111e2e02ccecd8d223d955e">Values</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to store values extracted from input stream.  <a href="#a158511e3d111e2e02ccecd8d223d955e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
Values::value_type::second_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a1b83774c0c961ea9284b9379c1b39a56">ValueType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type in map.  <a href="#a1b83774c0c961ea9284b9379c1b39a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Values::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#aca9a2f84c5b149070bd4292108f71085">KeyType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type in map.  <a href="#aca9a2f84c5b149070bd4292108f71085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a40f5768d2e3032cb06074219c1d4e013">Char</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="class_parser.html">Parser</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a1de985101197cc429c35a386aa1afc50">Parsers</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a8993c7939354076bced43f314c32bcba">TupleParser</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a3c5a22e7c6f3520bc9f3e1c2d722a8c6">TupleParser</a> (const <a class="el" href="class_parser.html">Parser</a> &amp;v, const <a class="el" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> &amp;name=<a class="el" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>(), const <a class="el" href="class_parser.html">Parser</a> &amp;b=<a class="el" href="class_blank_parser.html">BlankParser</a>(), const <a class="el" href="class_parser.html">Parser</a> &amp;s=<a class="el" href="class_blank_parser.html">BlankParser</a>(), const <a class="el" href="class_parser.html">Parser</a> &amp;e=<a class="el" href="class_blank_parser.html">BlankParser</a>(), bool blanks=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a843fd3e26af770a75905b1f71e907a93">TupleParser</a> (const <a class="el" href="class_tuple_parser.html">TupleParser</a> &amp;l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a6a4d8d3284fc040fb51b9005c92f8b8a">Parse</a> (<a class="el" href="types_8h.html#a31c1a03c5c64b1c43cb777b140a3b97b">InStream</a> &amp;is)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a35eb5a182a0d3ee1517ca9cd096841c5">GetValues</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_i_parser.html#ac9caa917f49df06a50c4c3f712812df0">IParser::GetValues</a> implementation.  <a href="#a35eb5a182a0d3ee1517ca9cd096841c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#adaa18884a8b46eacb40e81f90e5e7f11">operator[]</a> (const <a class="el" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01">KeyType</a> &amp;k) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_i_parser.html#afa273b0ca8c936d08d7e8e9ead2ff021">IParser::operator[]</a> implementation.  <a href="#adaa18884a8b46eacb40e81f90e5e7f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tuple_parser.html">TupleParser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#acc78611f9497736c3ff5c7846ae9338a">Clone</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_i_parser.html#af14c3ebef6fdc69a43f16afa41812dfc">IParser::Clone</a> implementation.  <a href="#acc78611f9497736c3ff5c7846ae9338a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">Size</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b">SkipBlanks</a> (<a class="el" href="types_8h.html#a31c1a03c5c64b1c43cb777b140a3b97b">InStream</a> &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances to first non-blank character or <code>EOF</code>.  <a href="#acdd13769cd586ffa40e4cbb531ab202b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a> &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a5febe8abe029c13d93aaf44fc0b66e38">AddValue</a> (const <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a> &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds value to parsed value array.  <a href="#a5febe8abe029c13d93aaf44fc0b66e38"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2">name_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Name assigned to values in value map.  <a href="#a9d34ba9039198093b0ef9954c0f319e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parser.html">Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d">beginParser_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that identifies the start of the tuple.  <a href="#a08fe0c7b7a3875a6727441456da8477d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parser.html">Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae">valueParser_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses individual tuple components.  <a href="#a73e55bc0095de576ce64e7752065adae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parser.html">Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887">separatorParser_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses the expression separating two adjacent values.  <a href="#af452fb9a55bf1dfd60bdeafd93f9e887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parser.html">Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca">endParser_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses the expression identifying the end of the tuple.  <a href="#a5d8e219094ff3ef0ac630b0f959020ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa">values_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed values.  <a href="#a4865fd76e078b240937a0056fd992ffa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97">valueMap_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value map.  <a href="#a3474441a5cb96b958d8015d636a37c97"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;int SIZE = -1&gt;<br/>
class TupleParser&lt; SIZE &gt;</h3>

<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> for sequences of values of the same type separated by a separator expression and bound with a start/end expression. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00775">775</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a40f5768d2e3032cb06074219c1d4e013"></a><!-- doxytag: member="TupleParser::Char" ref="a40f5768d2e3032cb06074219c1d4e013" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_in_ch_stream.html#ae1a5946564c1752071f1d662fe5111fb">InStream::char_type</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a40f5768d2e3032cb06074219c1d4e013">Char</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00781">781</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca9a2f84c5b149070bd4292108f71085"></a><!-- doxytag: member="TupleParser::KeyType" ref="aca9a2f84c5b149070bd4292108f71085" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Values::key_type <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01">KeyType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Key type in map. </p>

<p>Implements <a class="el" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00780">780</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1de985101197cc429c35a386aa1afc50"></a><!-- doxytag: member="TupleParser::Parsers" ref="a1de985101197cc429c35a386aa1afc50" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt; <a class="el" href="class_parser.html">Parser</a> &gt; <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a1de985101197cc429c35a386aa1afc50">Parsers</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00782">782</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a158511e3d111e2e02ccecd8d223d955e"></a><!-- doxytag: member="TupleParser::Values" ref="a158511e3d111e2e02ccecd8d223d955e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">IParser::Values</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type used to store values extracted from input stream. </p>

<p>Implements <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00778">778</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b83774c0c961ea9284b9379c1b39a56"></a><!-- doxytag: member="TupleParser::ValueType" ref="a1b83774c0c961ea9284b9379c1b39a56" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Values::value_type::second_type <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value type in map. </p>

<p>Implements <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00779">779</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8993c7939354076bced43f314c32bcba"></a><!-- doxytag: member="TupleParser::TupleParser" ref="a8993c7939354076bced43f314c32bcba" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html">TupleParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00783">783</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3c5a22e7c6f3520bc9f3e1c2d722a8c6"></a><!-- doxytag: member="TupleParser::TupleParser" ref="a3c5a22e7c6f3520bc9f3e1c2d722a8c6" args="(const Parser &amp;v, const ValueID &amp;name=ValueID(), const Parser &amp;b=BlankParser(), const Parser &amp;s=BlankParser(), const Parser &amp;e=BlankParser(), bool blanks=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html">TupleParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_parser.html">Parser</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_parser.html">Parser</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em> = <code><a class="el" href="class_blank_parser.html">BlankParser</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_parser.html">Parser</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="class_blank_parser.html">BlankParser</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_parser.html">Parser</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em> = <code><a class="el" href="class_blank_parser.html">BlankParser</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blanks</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>value parser: used to parse individual tuple values </td></tr>
    <tr><td class="paramname">name</td><td>name assigned to parsed value array in returned value map </td></tr>
    <tr><td class="paramname">b</td><td>begin parser: parses expression identifying the start of the tuple </td></tr>
    <tr><td class="paramname">s</td><td>separator parser: parses text used to separate adjacent values </td></tr>
    <tr><td class="paramname">e</td><td>end parser: parses expression identifying end of tuple </td></tr>
    <tr><td class="paramname">blanks</td><td>skip blanks flag: if <code>true</code> blanks are skipped before applying each parser </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00791">791</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a843fd3e26af770a75905b1f71e907a93"></a><!-- doxytag: member="TupleParser::TupleParser" ref="a843fd3e26af770a75905b1f71e907a93" args="(const TupleParser &amp;l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html">TupleParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00794">794</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5febe8abe029c13d93aaf44fc0b66e38"></a><!-- doxytag: member="TupleParser::AddValue" ref="a5febe8abe029c13d93aaf44fc0b66e38" args="(const Values &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a> &gt;::size_type <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a5febe8abe029c13d93aaf44fc0b66e38">AddValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds value to parsed value array. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00882">882</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc78611f9497736c3ff5c7846ae9338a"></a><!-- doxytag: member="TupleParser::Clone" ref="acc78611f9497736c3ff5c7846ae9338a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tuple_parser.html">TupleParser</a>* <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#acc78611f9497736c3ff5c7846ae9338a">Clone</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_i_parser.html#af14c3ebef6fdc69a43f16afa41812dfc">IParser::Clone</a> implementation. </p>

<p>Implements <a class="el" href="struct_i_parser.html#af14c3ebef6fdc69a43f16afa41812dfc">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00867">867</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35eb5a182a0d3ee1517ca9cd096841c5"></a><!-- doxytag: member="TupleParser::GetValues" ref="a35eb5a182a0d3ee1517ca9cd096841c5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a>&amp; <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a35eb5a182a0d3ee1517ca9cd096841c5">GetValues</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_i_parser.html#ac9caa917f49df06a50c4c3f712812df0">IParser::GetValues</a> implementation. </p>

<p>Implements <a class="el" href="struct_i_parser.html#ac9caa917f49df06a50c4c3f712812df0">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00850">850</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaa18884a8b46eacb40e81f90e5e7f11"></a><!-- doxytag: member="TupleParser::operator[]" ref="adaa18884a8b46eacb40e81f90e5e7f11" args="(const KeyType &amp;k) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a>&amp; <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_i_parser.html#afa273b0ca8c936d08d7e8e9ead2ff021">IParser::operator[]</a> implementation. </p>

<p>Implements <a class="el" href="struct_i_parser.html#afa273b0ca8c936d08d7e8e9ead2ff021">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00859">859</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a4d8d3284fc040fb51b9005c92f8b8a"></a><!-- doxytag: member="TupleParser::Parse" ref="a6a4d8d3284fc040fb51b9005c92f8b8a" args="(InStream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a6a4d8d3284fc040fb51b9005c92f8b8a">Parse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a31c1a03c5c64b1c43cb777b140a3b97b">InStream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_i_parser.html#aeb456721f0c8eec0b98b41176866ba06" title="Performs parsing on input stream.">IParser::Parse</a> implementation: applies begin parser, loops over values/separators then applies end parser. Note that it will always parse as many values as possible to make it possible to report an error when the number of parsed values exceeds the number of required values. </p>
<p>( endReached = endParser_.Parse( is ) ) &amp;&amp; </p>

<p>Implements <a class="el" href="struct_i_parser.html#aeb456721f0c8eec0b98b41176866ba06">IParser</a>.</p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00803">803</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a571598bf6e30a6f086e27aa7e8d9fb22"></a><!-- doxytag: member="TupleParser::Size" ref="a571598bf6e30a6f086e27aa7e8d9fb22" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a571598bf6e30a6f086e27aa7e8d9fb22">Size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>size of tuple. </dd></dl>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00848">848</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="acdd13769cd586ffa40e4cbb531ab202b"></a><!-- doxytag: member="TupleParser::SkipBlanks" ref="acdd13769cd586ffa40e4cbb531ab202b" args="(InStream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#acdd13769cd586ffa40e4cbb531ab202b">SkipBlanks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a31c1a03c5c64b1c43cb777b140a3b97b">InStream</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advances to first non-blank character or <code>EOF</code>. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00871">871</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a08fe0c7b7a3875a6727441456da8477d"></a><!-- doxytag: member="TupleParser::beginParser_" ref="a08fe0c7b7a3875a6727441456da8477d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parser.html">Parser</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a08fe0c7b7a3875a6727441456da8477d">beginParser_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that identifies the start of the tuple. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00896">896</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d8e219094ff3ef0ac630b0f959020ca"></a><!-- doxytag: member="TupleParser::endParser_" ref="a5d8e219094ff3ef0ac630b0f959020ca" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parser.html">Parser</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a5d8e219094ff3ef0ac630b0f959020ca">endParser_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses the expression identifying the end of the tuple. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00902">902</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d34ba9039198093b0ef9954c0f319e2"></a><!-- doxytag: member="TupleParser::name_" ref="a9d34ba9039198093b0ef9954c0f319e2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a9d34ba9039198093b0ef9954c0f319e2">name_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name assigned to values in value map. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00894">894</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="af452fb9a55bf1dfd60bdeafd93f9e887"></a><!-- doxytag: member="TupleParser::separatorParser_" ref="af452fb9a55bf1dfd60bdeafd93f9e887" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parser.html">Parser</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#af452fb9a55bf1dfd60bdeafd93f9e887">separatorParser_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses the expression separating two adjacent values. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00900">900</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a24d12dd15f1c6149807e968bb585e9b1"></a><!-- doxytag: member="TupleParser::skipBlanks_" ref="a24d12dd15f1c6149807e968bb585e9b1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a24d12dd15f1c6149807e968bb585e9b1">skipBlanks_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Skip blanks flag: if <code>true</code> the <a class="el" href="class_tuple_parser.html#a6a4d8d3284fc040fb51b9005c92f8b8a">TupleParser::Parse</a> method skips all blanks before parsing input. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00892">892</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3474441a5cb96b958d8015d636a37c97"></a><!-- doxytag: member="TupleParser::valueMap_" ref="a3474441a5cb96b958d8015d636a37c97" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">Values</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a3474441a5cb96b958d8015d636a37c97">valueMap_</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value map. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00906">906</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73e55bc0095de576ce64e7752065adae"></a><!-- doxytag: member="TupleParser::valueParser_" ref="a73e55bc0095de576ce64e7752065adae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parser.html">Parser</a> <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a73e55bc0095de576ce64e7752065adae">valueParser_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> that parses individual tuple components. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00898">898</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4865fd76e078b240937a0056fd992ffa"></a><!-- doxytag: member="TupleParser::values_" ref="a4865fd76e078b240937a0056fd992ffa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int SIZE = -1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">ValueType</a> &gt; <a class="el" href="class_tuple_parser.html">TupleParser</a>&lt; SIZE &gt;::<a class="el" href="class_tuple_parser.html#a4865fd76e078b240937a0056fd992ffa">values_</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parsed values. </p>

<p>Definition at line <a class="el" href="parsers_8h_source.html#l00904">904</a> of file <a class="el" href="parsers_8h_source.html">parsers.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="parsers_8h_source.html">parsers.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 16 2012 15:04:36 for Parsley by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
