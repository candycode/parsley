<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Parsley: Parser.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Parsley
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Parser.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_parser_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef PARSER_H_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define PARSER_H_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="types_8h.html" title="Common types and wrappers.">types.h</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="_any_8h.html" title="Implementation of class to hold instances of any type.">Any.h</a>&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="_smart_ptr_8h.html" title="Implementaion of smart pointer class for automatic memory management.">SmartPtr.h</a>&quot;</span>
<a name="l00012"></a>00012 
<a name="l00014"></a><a class="code" href="struct_i_parser.html">00014</a> <span class="keyword">struct </span><a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00015"></a>00015 {
<a name="l00017"></a><a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc">00017</a>     <span class="keyword">typedef</span> std::map&lt; ValueID, Any &gt; <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00019"></a><a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464">00019</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>;
<a name="l00021"></a><a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01">00021</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>;
<a name="l00024"></a>00024     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="struct_i_parser.html#ac9caa917f49df06a50c4c3f712812df0">GetValues</a>() <span class="keyword">const</span> = 0;
<a name="l00029"></a>00029     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="struct_i_parser.html#afa273b0ca8c936d08d7e8e9ead2ff021">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k ) <span class="keyword">const</span> = 0; <span class="comment">// throw std::logic_error</span>
<a name="l00031"></a>00031 <span class="comment"></span>    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="struct_i_parser.html#aeb456721f0c8eec0b98b41176866ba06" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; ) = 0;
<a name="l00034"></a>00034     <span class="keyword">virtual</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>* <a class="code" href="struct_i_parser.html#af14c3ebef6fdc69a43f16afa41812dfc">Clone</a>() <span class="keyword">const</span> = 0;
<a name="l00035"></a>00035 };
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00048"></a><a class="code" href="class_parser.html">00048</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050 <span class="keyword">public</span>:
<a name="l00051"></a><a class="code" href="class_parser.html#af0075681010c0186a5f9d1731d156de4">00051</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_parser.html#af0075681010c0186a5f9d1731d156de4" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00052"></a><a class="code" href="class_parser.html#a018163ae152b228aa1e1e2b456ddacdc">00052</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_parser.html#a018163ae152b228aa1e1e2b456ddacdc" title="Value type in map.">ValueType</a>;
<a name="l00053"></a><a class="code" href="class_parser.html#a036e317120c23761a2afd30a898d9082">00053</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_parser.html#a036e317120c23761a2afd30a898d9082" title="Key type in map.">KeyType</a>;
<a name="l00054"></a><a class="code" href="class_parser.html#a6b68ab300b8dc46b930efb04f9984adb">00054</a>     <span class="keyword">typedef</span> <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InCharStream</a> <a class="code" href="class_parser.html#a6b68ab300b8dc46b930efb04f9984adb">InStream</a>;
<a name="l00057"></a><a class="code" href="class_parser.html#a27d00889d69a8686526bd5467ee71664">00057</a>     <span class="keywordtype">bool</span> <a class="code" href="class_parser.html#a27d00889d69a8686526bd5467ee71664">Empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> == 0; }
<a name="l00059"></a><a class="code" href="class_parser.html#a12234f6cd36b61af4b50c94a179422c1">00059</a>     <a class="code" href="class_parser.html#a12234f6cd36b61af4b50c94a179422c1" title="Default constructor.">Parser</a>() {}
<a name="l00061"></a><a class="code" href="class_parser.html#ad2aeed4b935633c7f04a57a5aa5a3cc1">00061</a>     <a class="code" href="class_parser.html#ad2aeed4b935633c7f04a57a5aa5a3cc1" title="Copy constructor.">Parser</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; l ) : <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>( l.<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> ? l.<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>-&gt;<a class="code" href="class_parser.html#a0893468a8e0ec160cca87a86457bc598" title="Implementation of IParser::Clone.">Clone</a>() : 0 ) {}
<a name="l00064"></a><a class="code" href="class_parser.html#a7240c9b17a42f087ea1b606bea517c9c">00064</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; <a class="code" href="class_parser.html#a7240c9b17a42f087ea1b606bea517c9c">Swap</a>( <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; l ) { <a class="code" href="class_parser.html#a7240c9b17a42f087ea1b606bea517c9c">::Swap</a>( <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>, l.<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; } 
<a name="l00066"></a><a class="code" href="class_parser.html#a34bbdc6314b6323fdce6075b5abe498a">00066</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; <a class="code" href="class_parser.html#a34bbdc6314b6323fdce6075b5abe498a" title="Assignment operator from other parser.">operator=</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; l ) { <a class="code" href="class_parser.html#a12234f6cd36b61af4b50c94a179422c1" title="Default constructor.">Parser</a>( l ).Swap( *<span class="keyword">this</span> ); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00068"></a><a class="code" href="class_parser.html#aadc5eb4db99ee73007345fb0a4ac3aec">00068</a>     <a class="code" href="class_parser.html#aadc5eb4db99ee73007345fb0a4ac3aec" title="Constructor from IParser implementation.">Parser</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>&amp; l ) : <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>( l.<a class="code" href="class_parser.html#a0893468a8e0ec160cca87a86457bc598" title="Implementation of IParser::Clone.">Clone</a>() ) {}
<a name="l00070"></a><a class="code" href="class_parser.html#ac0c1b0eb6d22fb1b9c4b9f7a542c6ae2">00070</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_parser.html#ac0c1b0eb6d22fb1b9c4b9f7a542c6ae2" title="Implementation of IParser::GetValues.">GetValues</a>()<span class="keyword"> const</span>
<a name="l00071"></a>00071 <span class="keyword">    </span>{ 
<a name="l00072"></a>00072         <a class="code" href="class_parser.html#a342bdbb6591b5f70730a60e2e1f280bb">CheckPointer</a>();
<a name="l00073"></a>00073         <span class="keywordflow">return</span> <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>-&gt;<a class="code" href="struct_i_parser.html#ac9caa917f49df06a50c4c3f712812df0">GetValues</a>(); <span class="comment">//will fail in release mode if exceptions off</span>
<a name="l00074"></a>00074     }
<a name="l00076"></a><a class="code" href="class_parser.html#a1202d037969599db7bcc0ff4a9c98f3b">00076</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_parser.html#a1202d037969599db7bcc0ff4a9c98f3b" title="Implementation of IParser::operator[].">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00077"></a>00077 <span class="keyword">    </span>{
<a name="l00078"></a>00078         <a class="code" href="class_parser.html#a342bdbb6591b5f70730a60e2e1f280bb">CheckPointer</a>();
<a name="l00079"></a>00079         <span class="keywordflow">return</span> <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>-&gt;operator[]( k );
<a name="l00080"></a>00080     }
<a name="l00082"></a><a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4">00082</a>     <span class="keywordtype">bool</span> <a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00083"></a>00083     {
<a name="l00084"></a>00084         <a class="code" href="class_parser.html#a342bdbb6591b5f70730a60e2e1f280bb">CheckPointer</a>();
<a name="l00085"></a>00085         <span class="keywordflow">if</span>( !<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">//in case exception are disabled in release mode</span>
<a name="l00086"></a>00086         <span class="keywordflow">return</span> <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>-&gt;<a class="code" href="struct_i_parser.html#aeb456721f0c8eec0b98b41176866ba06" title="Performs parsing on input stream.">Parse</a>( is );
<a name="l00087"></a>00087     }
<a name="l00089"></a><a class="code" href="class_parser.html#a0893468a8e0ec160cca87a86457bc598">00089</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>* <a class="code" href="class_parser.html#a0893468a8e0ec160cca87a86457bc598" title="Implementation of IParser::Clone.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_parser.html#a12234f6cd36b61af4b50c94a179422c1" title="Default constructor.">Parser</a>( *<span class="keyword">this</span> ); }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">private</span>:
<a name="l00095"></a><a class="code" href="class_parser.html#a342bdbb6591b5f70730a60e2e1f280bb">00095</a>     <span class="keywordtype">bool</span> <a class="code" href="class_parser.html#a342bdbb6591b5f70730a60e2e1f280bb">CheckPointer</a>()<span class="keyword"> const </span>
<a name="l00096"></a>00096 <span class="keyword">    </span>{
<a name="l00097"></a>00097         assert( <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> );
<a name="l00098"></a>00098         <span class="keywordflow">if</span>( !<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> ) <span class="keywordflow">throw</span> std::runtime_error( <span class="stringliteral">&quot;NULL Parser pointer&quot;</span> );
<a name="l00099"></a>00099         <span class="keywordflow">if</span>( !<a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">//release mode, no exceptions</span>
<a name="l00100"></a>00100         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00101"></a>00101     }
<a name="l00103"></a><a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3">00103</a>     <a class="code" href="class_smart_ptr.html">SmartPtr&lt; IParser &gt;</a> <a class="code" href="class_parser.html#a4643379bd6584c80f96f4c9d5dee4fe3" title="Owned instance of IParser to which all IParser method calls are forwarded.">pImpl_</a>;
<a name="l00104"></a>00104 };
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00126"></a><a class="code" href="class_rewind_manager.html">00126</a> <span class="comment"></span><span class="keyword">template</span>&lt; <span class="keyword">class</span> IstreamT &gt; <span class="keyword">class </span><a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">RewindManager</a>
<a name="l00127"></a>00127 {
<a name="l00129"></a><a class="code" href="class_rewind_manager.html#af65aeba76feb667dae5b68faf084e5d5">00129</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> IstreamT::streampos <a class="code" href="class_rewind_manager.html#af65aeba76feb667dae5b68faf084e5d5" title="Position in stream.">StreamPos</a>;
<a name="l00130"></a>00130 <span class="keyword">public</span>:
<a name="l00134"></a><a class="code" href="class_rewind_manager.html#a5ea5ef8b1e94cf4d657db735df2ec067">00134</a>     <a class="code" href="class_rewind_manager.html#a5ea5ef8b1e94cf4d657db735df2ec067">RewindManager</a>( <span class="keywordtype">bool</span>&amp; flag, IstreamT&amp; is ) 
<a name="l00135"></a>00135         : <a class="code" href="class_rewind_manager.html#a45fca560be27e6a23f2a278b0b25c671" title="Stream get pointer position.">pos_</a>( is.tellg() ), <a class="code" href="class_rewind_manager.html#ad3ab840f12a6d5ab49712b32a6f52eae" title="Condition flag reference.">flag_</a>( flag ), <a class="code" href="class_rewind_manager.html#aef0f6cfb1c3aa627ac3833a2f59c487b" title="Input stream reference.">is_</a>( is ) {}
<a name="l00140"></a><a class="code" href="class_rewind_manager.html#ab5dacc6ac5d170ab9b6b889d1c3a84ed">00140</a>     <a class="code" href="class_rewind_manager.html#ab5dacc6ac5d170ab9b6b889d1c3a84ed">~RewindManager</a>()
<a name="l00141"></a>00141     { 
<a name="l00142"></a>00142         <span class="keywordflow">if</span>( !<a class="code" href="class_rewind_manager.html#ad3ab840f12a6d5ab49712b32a6f52eae" title="Condition flag reference.">flag_</a> ) 
<a name="l00143"></a>00143         {
<a name="l00144"></a>00144 <span class="comment">//#ifdef __GNUC__ // note: gcc requires eof flag not set for seekg to work</span>
<a name="l00145"></a>00145                   <span class="comment">//       doesn&#39;t arm to force a clear on vc++ either </span>
<a name="l00146"></a>00146             <a class="code" href="class_rewind_manager.html#aef0f6cfb1c3aa627ac3833a2f59c487b" title="Input stream reference.">is_</a>.clear();
<a name="l00147"></a>00147 <span class="comment">//#endif</span>
<a name="l00148"></a>00148             <a class="code" href="class_rewind_manager.html#aef0f6cfb1c3aa627ac3833a2f59c487b" title="Input stream reference.">is_</a>.seekg( <a class="code" href="class_rewind_manager.html#a45fca560be27e6a23f2a278b0b25c671" title="Stream get pointer position.">pos_</a> );
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150     } <span class="comment">//rewind if condition not met</span>
<a name="l00151"></a>00151 <span class="keyword">private</span>:
<a name="l00153"></a><a class="code" href="class_rewind_manager.html#a45fca560be27e6a23f2a278b0b25c671">00153</a>     <span class="keyword">const</span> <a class="code" href="class_rewind_manager.html#af65aeba76feb667dae5b68faf084e5d5" title="Position in stream.">StreamPos</a> <a class="code" href="class_rewind_manager.html#a45fca560be27e6a23f2a278b0b25c671" title="Stream get pointer position.">pos_</a>;
<a name="l00155"></a><a class="code" href="class_rewind_manager.html#ad3ab840f12a6d5ab49712b32a6f52eae">00155</a>     <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; <a class="code" href="class_rewind_manager.html#ad3ab840f12a6d5ab49712b32a6f52eae" title="Condition flag reference.">flag_</a>;
<a name="l00157"></a><a class="code" href="class_rewind_manager.html#aef0f6cfb1c3aa627ac3833a2f59c487b">00157</a>     IstreamT&amp; <a class="code" href="class_rewind_manager.html#aef0f6cfb1c3aa627ac3833a2f59c487b" title="Input stream reference.">is_</a>;
<a name="l00158"></a>00158 };
<a name="l00159"></a>00159 
<a name="l00161"></a><a class="code" href="_parser_8h.html#ababb1eaef69b11f0c885eaec72a368ec">00161</a> <span class="keyword">typedef</span> <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">RewindManager&lt; InStream &gt;</a> <a class="code" href="_parser_8h.html#ababb1eaef69b11f0c885eaec72a368ec" title="Convenience typedef.">REWIND</a>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00166"></a><a class="code" href="class_and_parser.html">00166</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168 <span class="keyword">public</span>:
<a name="l00169"></a><a class="code" href="class_and_parser.html#a8a4a68aad44c481b7705e1f0c5cdf51d">00169</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_and_parser.html#a8a4a68aad44c481b7705e1f0c5cdf51d" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00170"></a><a class="code" href="class_and_parser.html#a3c4182ba76ffa62731d6515ad9003e71">00170</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_and_parser.html#a3c4182ba76ffa62731d6515ad9003e71" title="Value type in map.">ValueType</a>;
<a name="l00171"></a><a class="code" href="class_and_parser.html#a8e3f817f44430ec33ed3cee4e05a6a45">00171</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_and_parser.html#a8e3f817f44430ec33ed3cee4e05a6a45" title="Key type in map.">KeyType</a>;
<a name="l00173"></a><a class="code" href="class_and_parser.html#ac1235ebc9834caa38a9493a7324e7eaa">00173</a>     <a class="code" href="class_and_parser.html#ac1235ebc9834caa38a9493a7324e7eaa" title="Default constructor; enables skipping of leading blanks.">AndParser</a>() : <a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a>( true ) {}
<a name="l00175"></a><a class="code" href="class_and_parser.html#a0f4056fe58292d918757117f829a1ae7">00175</a>     <a class="code" href="class_and_parser.html#ac1235ebc9834caa38a9493a7324e7eaa" title="Default constructor; enables skipping of leading blanks.">AndParser</a>( <span class="keyword">const</span> <a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a>&amp; p ) 
<a name="l00176"></a>00176         : <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>( p.<a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a> ), <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>( p.<a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a> ), 
<a name="l00177"></a>00177           <a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a>( p.<a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a> ) {}
<a name="l00180"></a><a class="code" href="class_and_parser.html#a160232ac3389bb92b8565da1f5259c39">00180</a>     <a class="code" href="class_and_parser.html#a160232ac3389bb92b8565da1f5259c39">AndParser</a>( <span class="keywordtype">bool</span> b ) : <a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a>( b ) {}
<a name="l00184"></a><a class="code" href="class_and_parser.html#abb775e74869390ae0c25028511046e63">00184</a>     <a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a>&amp; <a class="code" href="class_and_parser.html#abb775e74869390ae0c25028511046e63">AddFront</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.push_front( p );  <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00188"></a><a class="code" href="class_and_parser.html#a3a86d15b8c1b7d89098718d74f4636f9">00188</a>     <a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a>&amp; <a class="code" href="class_and_parser.html#a3a86d15b8c1b7d89098718d74f4636f9">Add</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.push_back( p );  <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00191"></a><a class="code" href="class_and_parser.html#a576883251e5e3ada48557ca334a35cb8">00191</a>     <span class="keywordtype">bool</span> <a class="code" href="class_and_parser.html#a576883251e5e3ada48557ca334a35cb8">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00192"></a>00192     {
<a name="l00193"></a>00193         <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>.clear();
<a name="l00194"></a>00194         <span class="comment">//if( !is.good() ) return false;</span>
<a name="l00195"></a>00195         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00196"></a>00196         {
<a name="l00197"></a>00197         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00198"></a>00198         <span class="keywordflow">for</span>( Parsers::iterator i = <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.begin();
<a name="l00199"></a>00199              i != <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.end();
<a name="l00200"></a>00200              ++i )
<a name="l00201"></a>00201         {
<a name="l00202"></a>00202             <span class="keywordflow">if</span>( <a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a>) <a class="code" href="class_and_parser.html#abf05624906f379ed533cbeb5dda3e6cf" title="Advance to first non-blank character.">SkipBlanks</a>( is );
<a name="l00203"></a>00203             <span class="keywordflow">if</span>( !i-&gt;Parse( is ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205         ok = <span class="keyword">true</span>;
<a name="l00206"></a>00206         }
<a name="l00207"></a>00207         <span class="keywordflow">return</span> ok;
<a name="l00208"></a>00208     }
<a name="l00210"></a><a class="code" href="class_and_parser.html#af7365d3d7854d95077651720f7a8ba59">00210</a>     <a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a>&amp; <a class="code" href="class_and_parser.html#af7365d3d7854d95077651720f7a8ba59" title="Used to chain parsers.">operator &gt;=</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <span class="keywordflow">return</span> <a class="code" href="class_and_parser.html#a3a86d15b8c1b7d89098718d74f4636f9">Add</a>( p ); } 
<a name="l00214"></a><a class="code" href="class_and_parser.html#a13850b6e9b9c6ec11907b2627aeb1054">00214</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_and_parser.html#a13850b6e9b9c6ec11907b2627aeb1054">GetValues</a>()<span class="keyword"> const</span>
<a name="l00215"></a>00215 <span class="keyword">    </span>{
<a name="l00216"></a>00216         <span class="keywordflow">if</span>( <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>.empty() ) <a class="code" href="class_and_parser.html#ae0b172674e39b5280841ad7de70515ad" title="Appends values extracted from child parsers to the value map.">AppendValues</a>();
<a name="l00217"></a>00217         <span class="keywordflow">return</span> <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>;
<a name="l00218"></a>00218     }
<a name="l00221"></a><a class="code" href="class_and_parser.html#a11676bb376cb4314daa7c4677aa6ab63">00221</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_and_parser.html#a11676bb376cb4314daa7c4677aa6ab63">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00222"></a>00222 <span class="keyword">    </span>{
<a name="l00223"></a>00223         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_and_parser.html#a13850b6e9b9c6ec11907b2627aeb1054">GetValues</a>();
<a name="l00224"></a>00224         Values::const_iterator i = v.find( k );
<a name="l00225"></a>00225         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00226"></a>00226         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228     
<a name="l00230"></a><a class="code" href="class_and_parser.html#abfb40fcca1d7d3373a631268b474a911">00230</a>     <a class="code" href="class_and_parser.html" title="Applies a sequence of parsers to the input stream in the order supplied by the client code...">AndParser</a>* <a class="code" href="class_and_parser.html#abfb40fcca1d7d3373a631268b474a911" title="Implementation of IParser::Clone.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_and_parser.html#ac1235ebc9834caa38a9493a7324e7eaa" title="Default constructor; enables skipping of leading blanks.">AndParser</a>( *<span class="keyword">this</span> ); }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="keyword">private</span>:
<a name="l00234"></a><a class="code" href="class_and_parser.html#ae0b172674e39b5280841ad7de70515ad">00234</a>     <span class="keywordtype">void</span> <a class="code" href="class_and_parser.html#ae0b172674e39b5280841ad7de70515ad" title="Appends values extracted from child parsers to the value map.">AppendValues</a>()<span class="keyword"> const</span>
<a name="l00235"></a>00235 <span class="keyword">    </span>{
<a name="l00236"></a>00236         <span class="keywordflow">for</span>( Parsers::const_iterator i = <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.begin();
<a name="l00237"></a>00237              i != <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>.end();
<a name="l00238"></a>00238              ++i )
<a name="l00239"></a>00239         {
<a name="l00240"></a>00240             <span class="keywordflow">if</span>( i-&gt;GetValues().empty() ) <span class="keywordflow">continue</span>;
<a name="l00241"></a>00241             <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>.insert( i-&gt;GetValues().begin(), i-&gt;GetValues().end() );
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243     }
<a name="l00245"></a><a class="code" href="class_and_parser.html#abf05624906f379ed533cbeb5dda3e6cf">00245</a>     <span class="keywordtype">void</span> <a class="code" href="class_and_parser.html#abf05624906f379ed533cbeb5dda3e6cf" title="Advance to first non-blank character.">SkipBlanks</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247         <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">return</span>;
<a name="l00248"></a>00248         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00249"></a>00249         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; <a class="code" href="types_8h.html#a1f9b22c3625387791aa9814dddd995dd">::IsSpace</a>( c ) != 0 ) c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00250"></a>00250         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#a931551650506d4a41ee47fbc97a83483" title="Move back get pointer.">unget</a>();
<a name="l00251"></a>00251     }
<a name="l00253"></a><a class="code" href="class_and_parser.html#af9dc4a2ea5c80e18c5a2b752a3d70e92">00253</a>     <span class="keyword">typedef</span> std::list&lt; Parser &gt; <a class="code" href="class_and_parser.html#af9dc4a2ea5c80e18c5a2b752a3d70e92" title="Parser list type.">Parsers</a>;
<a name="l00255"></a><a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462">00255</a>     <a class="code" href="class_and_parser.html#af9dc4a2ea5c80e18c5a2b752a3d70e92" title="Parser list type.">Parsers</a> <a class="code" href="class_and_parser.html#a84fcb7898873b1385f5bc3ca9c337462" title="Parser list.">parsers_</a>;
<a name="l00258"></a><a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">00258</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_and_parser.html#a1d6d6f3a44e077385df5d7bdd9776b61">valueMap_</a>;
<a name="l00260"></a><a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97">00260</a>     <span class="keywordtype">bool</span> <a class="code" href="class_and_parser.html#a241e2f33dfa425c49234cc2e86d4ec97" title="Skip blanks flag.">skipBlanks_</a>;
<a name="l00261"></a>00261 };
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00266"></a><a class="code" href="class_multi_parser.html">00266</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_multi_parser.html" title="Applies the same parser a fixed number of times or until it fails.">MultiParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268 <span class="keyword">public</span>:
<a name="l00269"></a><a class="code" href="class_multi_parser.html#a798073498e07dcdea14541f7316a601a">00269</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_multi_parser.html#a798073498e07dcdea14541f7316a601a" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00270"></a><a class="code" href="class_multi_parser.html#afe5fe8e6100b1016cca3876e8215748b">00270</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_multi_parser.html#afe5fe8e6100b1016cca3876e8215748b" title="Value type in map.">ValueType</a>;
<a name="l00271"></a><a class="code" href="class_multi_parser.html#a5d28bf077b55d72ebc4084e129bbf326">00271</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_multi_parser.html#a5d28bf077b55d72ebc4084e129bbf326" title="Key type in map.">KeyType</a>;
<a name="l00278"></a><a class="code" href="class_multi_parser.html#aab584dead709a3c683876f1321be00ca">00278</a>     <a class="code" href="class_multi_parser.html#aab584dead709a3c683876f1321be00ca">MultiParser</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>&amp; p, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>(), <span class="keywordtype">int</span> countMin = 1, <span class="keywordtype">int</span> countMax = -1 ) 
<a name="l00279"></a>00279         : <a class="code" href="class_multi_parser.html#a99723b57cca1c58e481c8f2450229174" title="Parser to apply.">parser_</a>( p ), <a class="code" href="class_multi_parser.html#a93caca5f2dcf7403c910c3bd1474f191" title="Minimum amount of times to execute parser.">countMin_</a>( countMin ), <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a>( countMax ) {}
<a name="l00286"></a><a class="code" href="class_multi_parser.html#a815958b30f55404da21f07531d05e1b0">00286</a>     <span class="keywordtype">bool</span> <a class="code" href="class_multi_parser.html#a815958b30f55404da21f07531d05e1b0">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00287"></a>00287     {
<a name="l00288"></a>00288         <a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">valueMap_</a>.clear();
<a name="l00289"></a>00289         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00290"></a>00290         {
<a name="l00291"></a>00291         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00292"></a>00292         <span class="keywordtype">int</span> counter = 0;
<a name="l00293"></a>00293         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; 
<a name="l00294"></a>00294                ( counter &lt; <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a> || <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a> &lt; 0 ) &amp;&amp;
<a name="l00295"></a>00295                <a class="code" href="class_multi_parser.html#a99723b57cca1c58e481c8f2450229174" title="Parser to apply.">parser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is ) )
<a name="l00296"></a>00296         { 
<a name="l00297"></a>00297             ++counter;
<a name="l00298"></a>00298             <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_multi_parser.html#a99723b57cca1c58e481c8f2450229174" title="Parser to apply.">parser_</a>.<a class="code" href="class_parser.html#ac0c1b0eb6d22fb1b9c4b9f7a542c6ae2" title="Implementation of IParser::GetValues.">GetValues</a>();
<a name="l00299"></a>00299             <span class="keywordflow">for</span>( Values::const_iterator i = v.begin(); i != v.end(); ++i ) <a class="code" href="class_multi_parser.html#ae9d017344722c3131a00a3c6ba3ba795">values_</a>.push_back( i-&gt;second );
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301         <span class="keywordflow">if</span>( counter &lt; countMin_ || counter &gt; <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a> &amp;&amp; <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a> &gt;= 0 ) ok = <span class="keyword">false</span>;
<a name="l00302"></a>00302         <span class="keywordflow">else</span> ok = <span class="keyword">true</span>; <span class="comment">// counter in [countMin_, countMax_] dsgfds </span>
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304         <span class="keywordflow">return</span> ok;
<a name="l00305"></a>00305     }
<a name="l00308"></a><a class="code" href="class_multi_parser.html#acd21b350fe21d08d6f11ed040c261719">00308</a>     <a class="code" href="class_multi_parser.html" title="Applies the same parser a fixed number of times or until it fails.">MultiParser</a>&amp; <a class="code" href="class_multi_parser.html#acd21b350fe21d08d6f11ed040c261719">operator()</a>( <span class="keywordtype">int</span> minCount, <span class="keywordtype">int</span> maxCount = -1 )
<a name="l00309"></a>00309     { <a class="code" href="class_multi_parser.html#a93caca5f2dcf7403c910c3bd1474f191" title="Minimum amount of times to execute parser.">countMin_</a> = minCount; <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a> = maxCount; }
<a name="l00314"></a><a class="code" href="class_multi_parser.html#a1b1ffe1008415ec062fb84d009ccadcb">00314</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_multi_parser.html#a1b1ffe1008415ec062fb84d009ccadcb">GetValues</a>()<span class="keyword"> const</span>
<a name="l00315"></a>00315 <span class="keyword">    </span>{
<a name="l00316"></a>00316         <span class="keywordflow">if</span>( <a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">valueMap_</a>.empty() ) <a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_multi_parser.html#a0b0b5f55fdc02a83d27673941ea52410" title="Identifier for parsed value list in returned value map.">name_</a>, <a class="code" href="class_multi_parser.html#ae9d017344722c3131a00a3c6ba3ba795">values_</a> ) );
<a name="l00317"></a>00317         <span class="keywordflow">return</span> <a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">valueMap_</a>;
<a name="l00318"></a>00318     }
<a name="l00321"></a><a class="code" href="class_multi_parser.html#a44b2bbde7f11624f9f64b188df0e5d93">00321</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_multi_parser.html#a44b2bbde7f11624f9f64b188df0e5d93">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00322"></a>00322 <span class="keyword">    </span>{
<a name="l00323"></a>00323         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_multi_parser.html#a1b1ffe1008415ec062fb84d009ccadcb">GetValues</a>();
<a name="l00324"></a>00324         Values::const_iterator i = v.find( k );
<a name="l00325"></a>00325         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00326"></a>00326         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328  
<a name="l00330"></a><a class="code" href="class_multi_parser.html#ada83a8d3c394ac076a05aa46a6423136">00330</a>     <a class="code" href="class_multi_parser.html" title="Applies the same parser a fixed number of times or until it fails.">MultiParser</a>* <a class="code" href="class_multi_parser.html#ada83a8d3c394ac076a05aa46a6423136" title="Implementation of IParser::Clone.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_multi_parser.html#aab584dead709a3c683876f1321be00ca">MultiParser</a>( *<span class="keyword">this</span> ); }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="keyword">private</span>:
<a name="l00334"></a><a class="code" href="class_multi_parser.html#a0b0b5f55fdc02a83d27673941ea52410">00334</a>     <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> <a class="code" href="class_multi_parser.html#a0b0b5f55fdc02a83d27673941ea52410" title="Identifier for parsed value list in returned value map.">name_</a>;
<a name="l00336"></a><a class="code" href="class_multi_parser.html#a99723b57cca1c58e481c8f2450229174">00336</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_multi_parser.html#a99723b57cca1c58e481c8f2450229174" title="Parser to apply.">parser_</a>;
<a name="l00338"></a><a class="code" href="class_multi_parser.html#a93caca5f2dcf7403c910c3bd1474f191">00338</a>     <span class="keywordtype">int</span> <a class="code" href="class_multi_parser.html#a93caca5f2dcf7403c910c3bd1474f191" title="Minimum amount of times to execute parser.">countMin_</a>;
<a name="l00341"></a><a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">00341</a>     <span class="keywordtype">int</span> <a class="code" href="class_multi_parser.html#a3e7505a48b3ee27894a264fd8b879ee5">countMax_</a>;
<a name="l00345"></a><a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">00345</a>     <span class="keyword">mutable</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_multi_parser.html#a1e9f5a593ec6aa34ebf73c9cedd8d796">valueMap_</a>;
<a name="l00348"></a><a class="code" href="class_multi_parser.html#ae9d017344722c3131a00a3c6ba3ba795">00348</a>     std::list&lt; Any &gt; <a class="code" href="class_multi_parser.html#ae9d017344722c3131a00a3c6ba3ba795">values_</a>;   
<a name="l00349"></a>00349 };
<a name="l00350"></a>00350 
<a name="l00353"></a><a class="code" href="_parser_8h.html#aa916be08a74b101ed0057c19ef02d4f9">00353</a> <a class="code" href="class_multi_parser.html" title="Applies the same parser a fixed number of times or until it fails.">MultiParser</a> <a class="code" href="_parser_8h.html#aa916be08a74b101ed0057c19ef02d4f9">operator*</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <span class="keywordflow">return</span> <a class="code" href="class_multi_parser.html" title="Applies the same parser a fixed number of times or until it fails.">MultiParser</a>( p ); } 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00363"></a><a class="code" href="class_not_parser.html">00363</a> <span class="comment"></span><span class="keyword">template</span> &lt; <span class="keyword">class</span> ParserT &gt; <span class="keyword">class </span><a class="code" href="class_not_parser.html" title="Parse method returns the negation of what the contained parser Parse method returns.">NotParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365 <span class="keyword">public</span>:
<a name="l00366"></a><a class="code" href="class_not_parser.html#a9b034b4e73e642103e4f7f5aa3c6d9e6">00366</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_not_parser.html#a9b034b4e73e642103e4f7f5aa3c6d9e6" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00367"></a><a class="code" href="class_not_parser.html#a12cbef28d32a147fcc096fbabff37b91">00367</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_not_parser.html#a12cbef28d32a147fcc096fbabff37b91" title="Value type in map.">ValueType</a>;
<a name="l00368"></a><a class="code" href="class_not_parser.html#aeecedf0d2feec94e4a3b91a7f87951ee">00368</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_not_parser.html#aeecedf0d2feec94e4a3b91a7f87951ee" title="Key type in map.">KeyType</a>;
<a name="l00373"></a><a class="code" href="class_not_parser.html#accc3b1a7e16fe62a1086b1c3b6d2a9a8">00373</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_not_parser.html#accc3b1a7e16fe62a1086b1c3b6d2a9a8">GetValues</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_not_parser.html#aae6fc010924eaf53f0a7b764e1d7339d" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>; }
<a name="l00374"></a><a class="code" href="class_not_parser.html#a16bd5d4f83fca0f67974d2a607933527">00374</a>     <a class="code" href="class_not_parser.html" title="Parse method returns the negation of what the contained parser Parse method returns.">NotParser</a>* <a class="code" href="class_not_parser.html#a16bd5d4f83fca0f67974d2a607933527">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_not_parser.html" title="Parse method returns the negation of what the contained parser Parse method returns.">NotParser&lt; ParserT &gt;</a>( *this ); }
<a name="l00375"></a><a class="code" href="class_not_parser.html#ac24e9743b96f13948cbed11483bfd771">00375</a>     <span class="keywordtype">bool</span> <a class="code" href="class_not_parser.html#ac24e9743b96f13948cbed11483bfd771" title="Performs parsing on input stream.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377         <span class="comment">// if ParserT::Parse returns true</span>
<a name="l00378"></a>00378         <span class="comment">// the get pointer will point one char</span>
<a name="l00379"></a>00379         <span class="comment">// past the end of the validated char sequence,</span>
<a name="l00380"></a>00380         <span class="comment">// it is therefore required to save the pointer</span>
<a name="l00381"></a>00381         <span class="comment">// before the invocation and restore it in case</span>
<a name="l00382"></a>00382         <span class="comment">// the parser validates the string to make it point</span>
<a name="l00383"></a>00383         <span class="comment">// to one char before the beginning of the string to</span>
<a name="l00384"></a>00384         <span class="comment">// validate</span>
<a name="l00385"></a>00385         <a class="code" href="class_not_parser.html#aae6fc010924eaf53f0a7b764e1d7339d" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>.clear();
<a name="l00386"></a>00386         <a class="code" href="parsers_8h.html#afbeda3fd1bdc8c37d01bdf9f5c8274ff">String</a> s;
<a name="l00387"></a>00387         <a class="code" href="types_8h.html#afa2b962aea73d84a539a95556407a059">Char</a> c = 0;
<a name="l00388"></a>00388         <a class="code" href="types_8h.html#ac88fd1b755dd7fbb41068b7d30994e7e">StreamPos</a> pos = is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>();
<a name="l00389"></a>00389         <span class="keywordflow">while</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() &amp;&amp; !<a class="code" href="class_not_parser.html#a4442ccc361b19ac154f874c7744dfaea" title="Contained parser.">parser_</a>.Parse( is ) )
<a name="l00390"></a>00390         {
<a name="l00391"></a>00391             c = is.<a class="code" href="class_in_ch_stream.html#af107a5190c5604aa38d4200bc80c7531">get</a>();
<a name="l00392"></a>00392             <span class="keywordflow">if</span>( !is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) <span class="keywordflow">break</span>;
<a name="l00393"></a>00393             s.push_back( c );
<a name="l00394"></a>00394             pos = is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>();
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396         <span class="keywordflow">if</span>( is.<a class="code" href="class_in_ch_stream.html#a8e6cb2df2d6be720436366cac11000b3">good</a>() ) is.<a class="code" href="class_in_ch_stream.html#acb6a4bb4f9d6c4d702b0eb9d0d86f9c3">seekg</a>( pos );
<a name="l00397"></a>00397         <span class="keywordflow">if</span>( s.length() &gt; 0 ) <a class="code" href="class_not_parser.html#aae6fc010924eaf53f0a7b764e1d7339d" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>.insert( std::make_pair( <a class="code" href="class_not_parser.html#a829f758aabe6bfddebe3a8b904aa1ac1" title="Value identifier used as key in value map.">name_</a>, s ) );
<a name="l00398"></a>00398         <span class="keywordflow">return</span> s.length() &gt; 0;
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400 
<a name="l00403"></a><a class="code" href="class_not_parser.html#a74bbe273511b2199cf9bacecc8e47a5f">00403</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_not_parser.html#a74bbe273511b2199cf9bacecc8e47a5f">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00404"></a>00404 <span class="keyword">    </span>{
<a name="l00405"></a>00405         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_not_parser.html#accc3b1a7e16fe62a1086b1c3b6d2a9a8">GetValues</a>();
<a name="l00406"></a>00406         Values::const_iterator i = v.find( k );
<a name="l00407"></a>00407         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00408"></a>00408         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00409"></a>00409     }
<a name="l00412"></a><a class="code" href="class_not_parser.html#ad858af1cba57768005b2e1c05c1b3875">00412</a>     <a class="code" href="class_not_parser.html#ad858af1cba57768005b2e1c05c1b3875">NotParser</a>( <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_not_parser.html#a829f758aabe6bfddebe3a8b904aa1ac1" title="Value identifier used as key in value map.">name_</a>( name ) {}
<a name="l00415"></a><a class="code" href="class_not_parser.html#a2e69cdb607fb2fa46d40cf3b4315797f">00415</a>     <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <a class="code" href="class_not_parser.html#a2e69cdb607fb2fa46d40cf3b4315797f">NotParser</a>( <span class="keyword">const</span> <a class="code" href="class_tuple_parser.html">T</a>&amp; v, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_not_parser.html#a4442ccc361b19ac154f874c7744dfaea" title="Contained parser.">parser_</a>( v ), <a class="code" href="class_not_parser.html#a829f758aabe6bfddebe3a8b904aa1ac1" title="Value identifier used as key in value map.">name_</a>( name ) {}
<a name="l00416"></a>00416 <span class="keyword">private</span>:
<a name="l00418"></a><a class="code" href="class_not_parser.html#a4442ccc361b19ac154f874c7744dfaea">00418</a>     ParserT <a class="code" href="class_not_parser.html#a4442ccc361b19ac154f874c7744dfaea" title="Contained parser.">parser_</a>;
<a name="l00420"></a><a class="code" href="class_not_parser.html#aae6fc010924eaf53f0a7b764e1d7339d">00420</a>     <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_not_parser.html#aae6fc010924eaf53f0a7b764e1d7339d" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>;
<a name="l00422"></a><a class="code" href="class_not_parser.html#a829f758aabe6bfddebe3a8b904aa1ac1">00422</a>     <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> <a class="code" href="class_not_parser.html#a829f758aabe6bfddebe3a8b904aa1ac1" title="Value identifier used as key in value map.">name_</a>;
<a name="l00423"></a>00423 };
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">//-----------------------------------------------------------------------------</span>
<a name="l00430"></a><a class="code" href="class_optional_parser.html">00430</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_optional_parser.html" title="Parser for optional expressions.">OptionalParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432 <span class="keyword">public</span>:
<a name="l00433"></a><a class="code" href="class_optional_parser.html#a9cbcf16ccd00481100a0622c141f68ce">00433</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_optional_parser.html#a9cbcf16ccd00481100a0622c141f68ce" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00434"></a><a class="code" href="class_optional_parser.html#af89defbe645219710e7702757575c5ab">00434</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_optional_parser.html#af89defbe645219710e7702757575c5ab" title="Value type in map.">ValueType</a>;
<a name="l00435"></a><a class="code" href="class_optional_parser.html#a0059dd138e67a695d39c478a86de5027">00435</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_optional_parser.html#a0059dd138e67a695d39c478a86de5027" title="Key type in map.">KeyType</a>;
<a name="l00436"></a><a class="code" href="class_optional_parser.html#a983773cbc7a893585d2d9c2318d34547">00436</a>     <a class="code" href="class_optional_parser.html#a983773cbc7a893585d2d9c2318d34547">OptionalParser</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5" title="Contained parser.">parser_</a>( p ), <a class="code" href="class_optional_parser.html#a2817152ec99e314b7141ddef85268896" title="Value identifier used as key in value map.">name_</a>( name ) {}
<a name="l00441"></a><a class="code" href="class_optional_parser.html#a4e27ac4e765238b4185671a92dc05a52">00441</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_optional_parser.html#a4e27ac4e765238b4185671a92dc05a52">GetValues</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="class_optional_parser.html#ad96a314ee1fb42b546309c9177860121" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>; }
<a name="l00442"></a><a class="code" href="class_optional_parser.html#a1f8083050eda5f916fa894b29b42bfed">00442</a>     <a class="code" href="class_optional_parser.html" title="Parser for optional expressions.">OptionalParser</a>* <a class="code" href="class_optional_parser.html#a1f8083050eda5f916fa894b29b42bfed">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_optional_parser.html#a983773cbc7a893585d2d9c2318d34547">OptionalParser</a>( *<span class="keyword">this</span> ); }
<a name="l00444"></a><a class="code" href="class_optional_parser.html#aa86af12a2d5f26acf6c4cea85b8027d4">00444</a>     <span class="keywordtype">bool</span> <a class="code" href="class_optional_parser.html#aa86af12a2d5f26acf6c4cea85b8027d4" title="Implementation of IParser::Parse: apply parser and always returns true.">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446         <a class="code" href="class_optional_parser.html#ad96a314ee1fb42b546309c9177860121" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>.clear();
<a name="l00447"></a>00447         <span class="keywordflow">if</span>( <a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5" title="Contained parser.">parser_</a>.<a class="code" href="class_parser.html#adc2bbc49893f5268b95ceb65ed51b0b4" title="Implementation of IParser::Parse.">Parse</a>( is ) ) <a class="code" href="class_optional_parser.html#ad96a314ee1fb42b546309c9177860121" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a> = <a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5" title="Contained parser.">parser_</a>.<a class="code" href="class_parser.html#ac0c1b0eb6d22fb1b9c4b9f7a542c6ae2" title="Implementation of IParser::GetValues.">GetValues</a>();
<a name="l00448"></a>00448         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00449"></a>00449     }
<a name="l00452"></a><a class="code" href="class_optional_parser.html#af2bd6825cf92a3f9c450fe4980eeb719">00452</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_optional_parser.html#af2bd6825cf92a3f9c450fe4980eeb719">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00453"></a>00453 <span class="keyword">    </span>{
<a name="l00454"></a>00454         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_optional_parser.html#a4e27ac4e765238b4185671a92dc05a52">GetValues</a>();
<a name="l00455"></a>00455         Values::const_iterator i = v.find( k );
<a name="l00456"></a>00456         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00457"></a>00457         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00458"></a>00458     }
<a name="l00461"></a><a class="code" href="class_optional_parser.html#a234914a25b21195046aef7ef125b4781">00461</a>     <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <a class="code" href="class_optional_parser.html#a234914a25b21195046aef7ef125b4781">OptionalParser</a>( <span class="keyword">const</span> <a class="code" href="class_tuple_parser.html">T</a>&amp; v, <span class="keyword">const</span> <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>&amp; name = <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a>() ) : <a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5" title="Contained parser.">parser_</a>( v ), <a class="code" href="class_optional_parser.html#a2817152ec99e314b7141ddef85268896" title="Value identifier used as key in value map.">name_</a>( name ) {}
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keyword">private</span>:
<a name="l00465"></a><a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5">00465</a>     <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a> <a class="code" href="class_optional_parser.html#a930790cbdcc37da8c5324695cc364ac5" title="Contained parser.">parser_</a>;
<a name="l00467"></a><a class="code" href="class_optional_parser.html#ad96a314ee1fb42b546309c9177860121">00467</a>     <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> <a class="code" href="class_optional_parser.html#ad96a314ee1fb42b546309c9177860121" title="Value map: contains a (NotParser::name_,String) pair.">valueMap_</a>;
<a name="l00469"></a><a class="code" href="class_optional_parser.html#a2817152ec99e314b7141ddef85268896">00469</a>     <a class="code" href="types_8h.html#a9da29ecbcffda5162dfb3fd1e814ee57">ValueID</a> <a class="code" href="class_optional_parser.html#a2817152ec99e314b7141ddef85268896" title="Value identifier used as key in value map.">name_</a>;
<a name="l00470"></a>00470 };
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00478"></a><a class="code" href="class_or_parser.html">00478</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00479"></a>00479 {
<a name="l00480"></a>00480 <span class="keyword">public</span>:
<a name="l00481"></a><a class="code" href="class_or_parser.html#a0aab977185a1a9b4da90b16f76bf38ef">00481</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_or_parser.html#a0aab977185a1a9b4da90b16f76bf38ef" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00482"></a><a class="code" href="class_or_parser.html#a446b5e4dd9f8550b393bae5a1cf768ea">00482</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_or_parser.html#a446b5e4dd9f8550b393bae5a1cf768ea" title="Value type in map.">ValueType</a>;
<a name="l00483"></a><a class="code" href="class_or_parser.html#a582b538c1b56d0e31d5065bc9cb84da7">00483</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_or_parser.html#a582b538c1b56d0e31d5065bc9cb84da7" title="Key type in map.">KeyType</a>;
<a name="l00487"></a><a class="code" href="class_or_parser.html#a53d1799c068ac65251c56b78223a96a4">00487</a>     <a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a>&amp; <a class="code" href="class_or_parser.html#a53d1799c068ac65251c56b78223a96a4">Add</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.push_back( p ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00489"></a><a class="code" href="class_or_parser.html#abe437302aa4ca478d8c51773662389e9">00489</a>     <a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a>&amp; <a class="code" href="class_or_parser.html#abe437302aa4ca478d8c51773662389e9" title="Invokes OrParser::Add(const Parser&amp;).">operator/=</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <span class="keywordflow">return</span> <a class="code" href="class_or_parser.html#a53d1799c068ac65251c56b78223a96a4">Add</a>(p); }
<a name="l00491"></a><a class="code" href="class_or_parser.html#a7df807efddfae78311383fc0cdcbde3c">00491</a>     <a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a>&amp; <a class="code" href="class_or_parser.html#a7df807efddfae78311383fc0cdcbde3c" title="Convenience method to apped a parser non contained into a Parser instance.">operator/=</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>&amp; p ) { <span class="keywordflow">return</span> <a class="code" href="class_or_parser.html#a53d1799c068ac65251c56b78223a96a4">Add</a>( p ); }
<a name="l00493"></a><a class="code" href="class_or_parser.html#a2489520ebf5f023fb7546e0e951774a7">00493</a>     <a class="code" href="class_or_parser.html#a2489520ebf5f023fb7546e0e951774a7" title="Default constructor.">OrParser</a>() : <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a>( <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end() ) {}
<a name="l00495"></a><a class="code" href="class_or_parser.html#afd587c1113d6d9ad56df3e5139b94992">00495</a>     <a class="code" href="class_or_parser.html#afd587c1113d6d9ad56df3e5139b94992" title="Copy constructor.">OrParser</a>( <span class="keyword">const</span> <a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a>&amp; op ) : <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>( op.<a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a> ), <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a>( <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end() ) {}  
<a name="l00500"></a><a class="code" href="class_or_parser.html#ab269ee0e78931d2133e3de3c8b5038fd">00500</a>     <span class="keywordtype">bool</span> <a class="code" href="class_or_parser.html#ab269ee0e78931d2133e3de3c8b5038fd">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00501"></a>00501     {
<a name="l00502"></a>00502         <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a> = <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end();
<a name="l00503"></a>00503         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00504"></a>00504         {
<a name="l00505"></a>00505         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00506"></a>00506         Parsers::iterator i = <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.begin();
<a name="l00507"></a>00507         <span class="keywordflow">for</span>( ; i != <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end(); ++i )
<a name="l00508"></a>00508         {
<a name="l00509"></a>00509             <span class="keyword">const</span> <a class="code" href="types_8h.html#ac88fd1b755dd7fbb41068b7d30994e7e">StreamPos</a> pos = is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>();
<a name="l00510"></a>00510             <span class="keywordflow">if</span>( !i-&gt;Parse( is ) )
<a name="l00511"></a>00511             {
<a name="l00512"></a>00512                 is.<a class="code" href="class_in_ch_stream.html#acb6a4bb4f9d6c4d702b0eb9d0d86f9c3">seekg</a>( pos );
<a name="l00513"></a>00513                 <span class="keywordflow">continue</span>;
<a name="l00514"></a>00514             }
<a name="l00515"></a>00515             <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l00516"></a>00516         }
<a name="l00517"></a>00517         <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a> = i;
<a name="l00518"></a>00518         ok = i != <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end();
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520         <span class="keywordflow">return</span> ok; 
<a name="l00521"></a>00521     }
<a name="l00524"></a><a class="code" href="class_or_parser.html#a40e3d0ba485e75a5362a83933c7edef1">00524</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_or_parser.html#a40e3d0ba485e75a5362a83933c7edef1">GetValues</a>()<span class="keyword"> const</span>
<a name="l00525"></a>00525 <span class="keyword">    </span>{
<a name="l00526"></a>00526         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00527"></a>00527         <span class="keywordflow">return</span> <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a> != <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>.end() ? <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a>-&gt;GetValues() : dummy;
<a name="l00528"></a>00528     }
<a name="l00531"></a><a class="code" href="class_or_parser.html#abc8b3dd13932df2382e8ee2e10e4025d">00531</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_or_parser.html#abc8b3dd13932df2382e8ee2e10e4025d">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00532"></a>00532 <span class="keyword">    </span>{
<a name="l00533"></a>00533         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_or_parser.html#a40e3d0ba485e75a5362a83933c7edef1">GetValues</a>();
<a name="l00534"></a>00534         Values::const_iterator i = v.find( k );
<a name="l00535"></a>00535         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00536"></a>00536         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00537"></a>00537     }
<a name="l00538"></a>00538 
<a name="l00540"></a><a class="code" href="class_or_parser.html#a9cb5bb1242b479ed9fe8b9b5d3c0d08d">00540</a>     <a class="code" href="class_or_parser.html" title="Ordered OR parser: invokes the contained parsers until one returns true.">OrParser</a>* <a class="code" href="class_or_parser.html#a9cb5bb1242b479ed9fe8b9b5d3c0d08d" title="Implemetation of IParser::Clone.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_or_parser.html#a2489520ebf5f023fb7546e0e951774a7" title="Default constructor.">OrParser</a>( *<span class="keyword">this</span> ); }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="keyword">private</span>:
<a name="l00544"></a><a class="code" href="class_or_parser.html#ad3972104c16a26a8e3c2b53ad67031b3">00544</a>     <span class="keyword">typedef</span> std::list&lt; Parser &gt; <a class="code" href="class_or_parser.html#ad3972104c16a26a8e3c2b53ad67031b3" title="Parser list type.">Parsers</a>;
<a name="l00546"></a><a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f">00546</a>     <a class="code" href="class_or_parser.html#ad3972104c16a26a8e3c2b53ad67031b3" title="Parser list type.">Parsers</a> <a class="code" href="class_or_parser.html#add830acd6f0ef4e5d07b5013008e877f" title="Alternative parsers.">parsers_</a>;
<a name="l00548"></a><a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017">00548</a>     Parsers::const_iterator <a class="code" href="class_or_parser.html#a135f0f1be5862b0b43364a440241d017" title="Reference to matched parser or to parsers_.end() if no match found.">matchedParser_</a>;
<a name="l00549"></a>00549 };
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00563"></a><a class="code" href="class_greedy_or_parser.html">00563</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="class_greedy_or_parser.html" title="Or Parser: applies a set of parsers to the given stream and validates the input only of at least one ...">GreedyOrParser</a> : <span class="keyword">public</span> <a class="code" href="struct_i_parser.html" title="interface for parsers.">IParser</a>
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565 <span class="keyword">public</span>:
<a name="l00566"></a><a class="code" href="class_greedy_or_parser.html#a30efc34f76ba1cd316f72c3261136f20">00566</a>     <span class="keyword">typedef</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">IParser::Values</a> <a class="code" href="class_greedy_or_parser.html#a30efc34f76ba1cd316f72c3261136f20" title="Type used to store values extracted from input stream.">Values</a>;
<a name="l00567"></a><a class="code" href="class_greedy_or_parser.html#ac1833de8331de7d95e073a72381eabed">00567</a>     <span class="keyword">typedef</span> Values::value_type::second_type <a class="code" href="class_greedy_or_parser.html#ac1833de8331de7d95e073a72381eabed" title="Value type in map.">ValueType</a>;
<a name="l00568"></a><a class="code" href="class_greedy_or_parser.html#a6a17279c59b0ffde98b45c7ff2b47190">00568</a>     <span class="keyword">typedef</span> Values::key_type <a class="code" href="class_greedy_or_parser.html#a6a17279c59b0ffde98b45c7ff2b47190" title="Key type in map.">KeyType</a>;
<a name="l00570"></a><a class="code" href="class_greedy_or_parser.html#a8fbbadcae768733516b15e53fd5cd3f8">00570</a>     <a class="code" href="class_greedy_or_parser.html#a8fbbadcae768733516b15e53fd5cd3f8" title="Default constructor.">GreedyOrParser</a>() : <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a>( <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end() ) {}
<a name="l00572"></a><a class="code" href="class_greedy_or_parser.html#a5d20f582c72668abb61303d195e863f8">00572</a>     <a class="code" href="class_greedy_or_parser.html#a5d20f582c72668abb61303d195e863f8" title="Copy constructor.">GreedyOrParser</a>( <span class="keyword">const</span> <a class="code" href="class_greedy_or_parser.html" title="Or Parser: applies a set of parsers to the given stream and validates the input only of at least one ...">GreedyOrParser</a>&amp; op ) : <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>( op.<a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a> ), <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a>( <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end() ) {}  
<a name="l00576"></a><a class="code" href="class_greedy_or_parser.html#a39c9e32f18f767d4583b48e341922e75">00576</a>     <a class="code" href="class_greedy_or_parser.html" title="Or Parser: applies a set of parsers to the given stream and validates the input only of at least one ...">GreedyOrParser</a>&amp; <a class="code" href="class_greedy_or_parser.html#a39c9e32f18f767d4583b48e341922e75">Add</a>( <span class="keyword">const</span> <a class="code" href="class_parser.html" title="Implementation of IParser interface.">Parser</a>&amp; p ) { <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.push_back( p ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00580"></a><a class="code" href="class_greedy_or_parser.html#a2c5c2e7dea162533ea9429e46e62069d">00580</a>     <span class="keywordtype">bool</span> <a class="code" href="class_greedy_or_parser.html#a2c5c2e7dea162533ea9429e46e62069d">Parse</a>( <a class="code" href="class_in_ch_stream.html" title="Input character stream class featuring automatic tracking of current line and char.">InStream</a>&amp; is )
<a name="l00581"></a>00581     {
<a name="l00582"></a>00582         <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a> = <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end();
<a name="l00583"></a>00583         <a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>.clear();
<a name="l00584"></a>00584         <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l00585"></a>00585         {
<a name="l00586"></a>00586         <a class="code" href="class_rewind_manager.html" title="Utility class used to rewind an input stream if a monitored values is false.">REWIND</a> r( ok, is );
<a name="l00587"></a>00587         Parsers::iterator i = <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.begin();
<a name="l00588"></a>00588         <span class="keywordflow">for</span>( ; i != <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end(); ++i )
<a name="l00589"></a>00589         {
<a name="l00590"></a>00590             <span class="keyword">const</span> <a class="code" href="types_8h.html#a460d4b16daa8d41310a7be2ff5d3b289">StreamOff</a> pos = is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>();
<a name="l00591"></a>00591             <span class="keywordflow">if</span>( i-&gt;Parse( is ) ) <a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>.insert( std::make_pair( is.<a class="code" href="class_in_ch_stream.html#aca7b74a0b83c7cbd83435c4f6adb806b">tellg</a>(), i ) );
<a name="l00592"></a>00592             is.<a class="code" href="class_in_ch_stream.html#acb6a4bb4f9d6c4d702b0eb9d0d86f9c3">seekg</a>( pos );
<a name="l00593"></a>00593 
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595         <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a> = <a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>.empty() ? <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end() : ( --<a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>.end() )-&gt;second;
<a name="l00596"></a>00596         ok = i != <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end();
<a name="l00597"></a>00597         <span class="keywordflow">if</span>( ok ) is.<a class="code" href="class_in_ch_stream.html#acb6a4bb4f9d6c4d702b0eb9d0d86f9c3">seekg</a>( ( --<a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>.end() )-&gt;first );
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599         <span class="keywordflow">return</span> ok; 
<a name="l00600"></a>00600     }
<a name="l00603"></a><a class="code" href="class_greedy_or_parser.html#a2a3cb986f1d1ac4d63cfbf6366c268c3">00603</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; <a class="code" href="class_greedy_or_parser.html#a2a3cb986f1d1ac4d63cfbf6366c268c3">GetValues</a>()<span class="keyword"> const</span>
<a name="l00604"></a>00604 <span class="keyword">    </span>{
<a name="l00605"></a>00605         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a> dummy;
<a name="l00606"></a>00606         <span class="keywordflow">return</span> <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a> != <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>.end() ? <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a>-&gt;GetValues() : dummy;
<a name="l00607"></a>00607     }
<a name="l00610"></a><a class="code" href="class_greedy_or_parser.html#a9b61a0c0c036a344e5437e7f3bd0f3e2">00610</a>     <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#adbaf8be4f02668b152bc8054d1544464" title="Value type in map.">ValueType</a>&amp; <a class="code" href="class_greedy_or_parser.html#a9b61a0c0c036a344e5437e7f3bd0f3e2">operator[]</a>( <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a44d14e81d7112908e668eaaa4e721c01" title="Key type in map.">KeyType</a>&amp; k )<span class="keyword"> const</span>
<a name="l00611"></a>00611 <span class="keyword">    </span>{
<a name="l00612"></a>00612         <span class="keyword">const</span> <a class="code" href="struct_i_parser.html#a54bab0715eaee3ca350bc6f7d1e6c2dc" title="Type used to store values extracted from input stream.">Values</a>&amp; v = <a class="code" href="class_greedy_or_parser.html#a2a3cb986f1d1ac4d63cfbf6366c268c3">GetValues</a>();
<a name="l00613"></a>00613         Values::const_iterator i = v.find( k );
<a name="l00614"></a>00614         <span class="keywordflow">if</span>( i == v.end() ) <span class="keywordflow">throw</span> std::logic_error( <span class="stringliteral">&quot;Cannot find value&quot;</span> );
<a name="l00615"></a>00615         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00616"></a>00616     }
<a name="l00618"></a><a class="code" href="class_greedy_or_parser.html#aa2926186544c2c284def071e98c0a8c8">00618</a>     <a class="code" href="class_greedy_or_parser.html" title="Or Parser: applies a set of parsers to the given stream and validates the input only of at least one ...">GreedyOrParser</a>* <a class="code" href="class_greedy_or_parser.html#aa2926186544c2c284def071e98c0a8c8" title="Implementation of IParser::Clone.">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="class_greedy_or_parser.html#a8fbbadcae768733516b15e53fd5cd3f8" title="Default constructor.">GreedyOrParser</a>( *<span class="keyword">this</span> ); }
<a name="l00619"></a>00619 <span class="keyword">private</span>:
<a name="l00621"></a><a class="code" href="class_greedy_or_parser.html#ac2cf9b5d16f4ccc2e4cb5a6130674c99">00621</a>     <span class="keyword">typedef</span> std::list&lt; Parser &gt; <a class="code" href="class_greedy_or_parser.html#ac2cf9b5d16f4ccc2e4cb5a6130674c99" title="Parser list type.">Parsers</a>;
<a name="l00623"></a><a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c">00623</a>     <a class="code" href="class_greedy_or_parser.html#ac2cf9b5d16f4ccc2e4cb5a6130674c99" title="Parser list type.">Parsers</a> <a class="code" href="class_greedy_or_parser.html#a31578a4a4867eca7ded4a15782f1663c" title="Parser list.">parsers_</a>;
<a name="l00626"></a><a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">00626</a>     Parsers::const_iterator <a class="code" href="class_greedy_or_parser.html#a8a5540180af78ff753145150a7936442">matchedParser_</a>;
<a name="l00627"></a><a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">00627</a>     std::map&lt; StreamOff, Parsers::const_iterator &gt; <a class="code" href="class_greedy_or_parser.html#ad773b7f594bba2c8d86fc691cbb5f71d">matchedParsers_</a>;
<a name="l00628"></a>00628 };
<a name="l00629"></a>00629 <span class="preprocessor">#endif //LEXER_H_</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 16 2012 12:50:07 for Parsley by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
